
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Summerrose’s Blog</title>
  <meta name="author" content="ghren">

  
  <meta name="description" content="目录 概述
事件与种类
使用 Dispatch Source 概述 iOS 中有两种 Source，一种是 Run Loop Source ,一种是 Dispatch Source。 Source 可以理解为产生事件的地方，Source 产生事件，然后 Source 的回调函数负责 处理这些事件 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://alex1212112.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Summerrose’s Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>


  

</head>

<body   >
  <header role="banner"><hgroup>
</hgroup>

</header>
  <!-- <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:alex1212112.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav> -->
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/24/dispatch-source/">Dispatch Source</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-11-24T00:16:49+08:00" pubdate data-updated="true">Nov 24<span>th</span>, 2015</time>
        
         | <a href="/blog/2015/11/24/dispatch-source/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>目录</h3>

<ol>
<li>概述</li>
<li>事件与种类</li>
<li>使用 Dispatch Source</li>
</ol>


<h3>概述</h3>

<p>iOS 中有两种 Source，一种是 Run Loop Source ,一种是 Dispatch Source。</p>

<p>Source 可以理解为产生事件的地方，Source 产生事件，然后 Source 的回调函数负责 处理这些事件。</p>

<p>在 Run Loop 中， Run Loop Source 产生事件，之后唤醒 Run Loop， Run Loop 便执行该 Source 的回调函数。</p>

<p>Dispatch Source 也会产生一些特定的事件，当这些事件发生的时候，其回调的 block 会自动加入到 对应的 dispatch queue 中。</p>

<h3>事件与种类</h3>

<p>Dispatch Source 监控的事件主要有以下几种：</p>

<ol>
<li>Timer dispatch sources generate periodic notifications.</li>
<li>Signal dispatch sources notify you when a UNIX signal arrives.</li>
<li>Descriptor sources notify you of various file- and socket-based operations, such as:

<ul>
<li>When data is available for reading</li>
<li>When it is possible to write data</li>
<li>When files are deleted, moved, or renamed in the file system</li>
<li>When file meta information changes</li>
</ul>
</li>
<li>Process dispatch sources notify you of process-related events, such as:

<ul>
<li>When a process exits</li>
<li>When a process issues a fork or exec type of call</li>
<li>When a signal is delivered to the process</li>
</ul>
</li>
<li>Mach port dispatch sources notify you of Mach-related events.</li>
<li>Custom dispatch sources are ones you define and trigger yourself.</li>
</ol>


<p>对应着系统定义的 Dispatch Source 种类：</p>

<ol>
<li>DISPATCH_SOURCE_TYPE_TIMER 定时器</li>
<li>DISPATCH_SOURCE_TYPE_SIGNAL 接收到 UNIX 信号</li>
<li>DISPATCH_SOURCE_TYPE_READ 文件可读</li>
<li>DISPATCH_SOURCE_TYPE_WRITE 文件可写</li>
<li>DISPATCH_SOURCE_TYPE_VNODE 文件系统有变更</li>
<li>DISPATCH_SOURCE_TYPE_PROC 与进程相关的事件</li>
<li>DISPATCH_SOURCE_TYPE_MACH_SEND  Mach 端口发送事件</li>
<li>DISPATCH_SOURCE_TYPE_MACH_RECV  Mach 端口接收事件</li>
<li>DISPATCH_SOURCE_TYPE_DATA_ADD 用户自定义的事件－变量相加</li>
<li>DISPATCH_SOURCE_TYPE_DATA_OR  用户自定义的事件－变量相或</li>
</ol>


<p>这些事件都是来自于 XNU 内核中，kqueue 是用来处理这些事件的最好的一种方法，Dispatch Source 就是对 kqueue 的封装。</p>

<h3>使用 Dispatch Source</h3>

<p>使用 Dispatch Source 一般分为以下几步：</p>

<ol>
<li>创建 Dispatch Source</li>
<li>配置 Dispatch Source</li>
<li>启动 Dispathc source</li>
<li>手动或自动发送 Dispatch Source 事件</li>
</ol>


<h4>自定义 Dispatch Source</h4>

<p>首先创建并配置 Dispatch Sourcce</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.count = 0;
</span><span class='line'>dispatch_queue_t queue = dispatch_get_main_queue();
</span><span class='line'>self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, queue);//创建 Dispatch Source，种类为DISPATCH_SOURCE_TYPE_DATA_ADD，即获取到的变量会相加
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>dispatch_source_set_event_handler(self.source, ^{
</span><span class='line'>
</span><span class='line'>    UInt64 value = dispatch_source_get_data(self.source);
</span><span class='line'>    
</span><span class='line'>    self.count += value;
</span><span class='line'>    NSLog(@"n = %ld",(long)self.count);
</span><span class='line'>    
</span><span class='line'>});//配置 Dispatch Source 的回调 block，即当收到该 Source 事件时候，就把该 block 追加到对应的queue中
</span><span class='line'>
</span><span class='line'>dispatch_resume(self.source); //启动 Source， Source 默认是 suspend 的，需要手动启动</span></code></pre></td></tr></table></div></figure>


<p>发送 Dispatch Source 事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (IBAction)buttonDidClicked:(id)sender {
</span><span class='line'>    
</span><span class='line'>    self.count = 0.0;
</span><span class='line'>    
</span><span class='line'>    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT , 0);
</span><span class='line'>    
</span><span class='line'>    for (NSInteger i = 0; i &lt; 100; i++) {
</span><span class='line'>        
</span><span class='line'>        dispatch_async(queue, ^{
</span><span class='line'>            
</span><span class='line'>            dispatch_source_merge_data(self.source, 1);//发送 Source 事件
</span><span class='line'>            sleep(1);
</span><span class='line'>            
</span><span class='line'>        });
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>之后，我们点击按钮之后，就会通过全局并发队列 发送 100 次 Source 事件，不过并不会 回调 100 次 回调 Block， 这是因为对应的 队列在接收到 Source 事件之后，假如队列处于空闲状态，就会执行对应的 回调 Block，假如队列处于 busy 状态，该事件就会和后面的一系列同种事件通过一定的方式被合并起来（此例中是按照相加的方式），等到队列空闲的时候再执行。</p>

<h4>Dispatch Source Timer</h4>

<p>利用 Dispatch Source 的 DISPATCH_SOURCE_TYPE_TIMER 类型，我们可以创建一个 跨线程的 定时器（我们平时使用的 NSTimer 是基于 Run Loop 的 timer 事件，只能在对应的线程里触发）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t queue = dispatch_get_main_queue();
</span><span class='line'>self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);//创建一个 timer；
</span><span class='line'>dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);//配置 timer，从现在起，每两秒在主线程触发一次，精度为0s
</span><span class='line'>dispatch_source_set_event_handler(self.timer, ^{
</span><span class='line'>    
</span><span class='line'>    NSLog(@"%ld", self.count++);
</span><span class='line'>});//timer 触发之后的回调 block
</span><span class='line'>
</span><span class='line'>dispatch_resume(self.time); //启动 timer</span></code></pre></td></tr></table></div></figure>


<h3>参考资料</h3>

<ol>
<li><p><a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html">Dispatch Sources</a>;</p></li>
<li><p><a href="http://www.dreamingwish.com/article/grand-central-dispatch-basic-3.html">GCD入门（三）: Dispatch Sources</a>;</p></li>
<li><p><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF/Parse%E7%9A%84%E5%BA%95%E5%B1%82%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF.md">Parse的底层多线程处理思路：GCD高级用法</a>;</p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/21/run-loop/">Run Loop</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-11-21T21:17:04+08:00" pubdate data-updated="true">Nov 21<span>st</span>, 2015</time>
        
         | <a href="/blog/2015/11/21/run-loop/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>目录</h3>

<ol>
<li>介绍</li>
<li>用途</li>
<li>Runloop Mode</li>
<li>Runloop Mode Item</li>
<li>Run Loop 运行机制</li>
<li>自定义 input source</li>
</ol>


<h3>介绍</h3>

<p>Run Loop 正如其字面意思一样，表示运行循环，可以理解为一个 do-while 循环。Run Loop 与线程密切相关，每个线程对应着自己的一个 Run Loop，但是除了主线程的 Run Loop 是默认开启之外，剩下的线程的 Run Loop 一开始是不存在的，需要手动通过 <code>[NSRunLoop currentRunLoop]</code> 或 <code>CFRunLoopGetCurrent()</code> 获取当前线程的 Run Loop，这两个方法分别对应着 Foundation 框架和 Core Foundation 框架，它们的原理为，若当前线程对应的 Run Loop 存在的时候，直接返回该 Run Loop，当该线程当前不存在 Run Loop 时候，就创建当前线程的 Run Loop。 Foundation 框架的方法是对 Core Foundation 框架的方法做了一层封装，另外，NSRunloop 是非线程安全的，而 CFRunloopRef 是线程安全的。</p>

<h3>用途</h3>

<p>Run Loop 主要是用来保持线程常驻，从而接收事件的。比如常见的触摸事件，就是通过主线程的 Run Loop 来接收，然后再分发给相关的处理程序。</p>

<h3>Runloop Mode</h3>

<p>每一个 Run Loop 包含着多个 Runloop mode，每次运行的时候，它只会运行在一个特定的 Runloop mode 下，iOS 系统常用的 Runloop Mode 有两个：</p>

<ul>
<li>kCFRunLoopDefaultMode (NSDefaultRunLoopMode)</li>
<li>UITrackingRunLoopMode。</li>
</ul>


<p>另外还有一种特殊的commonModes：kCFRunLoopCommonModes(NSRunLoopCommonModes)， 这种情况可以理解为别的 Mode 的集合，假如一个 Run Loop 运行在 UITrackingRunLoopMode 下，那么它不但会接收被标记为 UITrackingRunLoopMode 的事件， 也会接收被标记为 NSRunLoopCommonModes 的事件。我们可能会遇到这种情况，当一个 UIScrollView 在滑动的时候，主线程的 NSTimer 事件就不触发了，这种情况是因为当 UIScrollView 在滑动的时候，主线程的 Run Loop 就处于 UITrackingRunLoopMode 下，只接收被标记为 UITrackingRunLoopMode 和 NSRunLoopCommonModes 的事件， 而 NSTimer 默认被标记为 NSDefaultRunLoopMode 的，所以该 timer 事件就被丢弃了。解决的办法是通过</p>

<p><code>- (void)addTimer:(NSTimer *)timer forMode:(NSString *)mode</code></p>

<p>来让此 timer 被标记为 NSRunLoopCommonModes 或 UITrackingRunLoopMode， 最好是被标记为 NSRunLoopCommonModes，这样，不管线程的 Run Loop 运行在什么 Mode 下，都能接收到事件了。</p>

<h3>Runloop Mode Item</h3>

<p>每一个 Runloop Mode 都包含若干 Mode Item，Mode Item 有3种，分别是 Source， Timer 和 Observer。每一个Run Loop 会运行在特定的 Mode 下，这个 Mode 里面必须包含至少一个 Mode Item，如果这个 Mode 里面没有包含任何 Mode Item，那么当前的 Run Loop 会立刻退出。我们可以通过以下方法来添加 Mode Item 到指定的 Mode 中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
</span><span class='line'>CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
</span><span class='line'>CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span></code></pre></td></tr></table></div></figure>


<p>通过下面的方法把 Mode Item 从指定 Mode 中移除</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
</span><span class='line'>CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
</span><span class='line'>CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span></code></pre></td></tr></table></div></figure>


<h4>Source</h4>

<p>Source（CFRunLoopSourceRef） 用来产生事件的，它有两个版本 Source0 和 Source1。</p>

<p>Source0 包含了一个回调函数，它无法主动唤醒线程的 Run Loop，需要先使用CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p>

<p>Source1 被称为基于 Port 的 source （Port based source）; 它主要用来进行线程间的通信，能主动唤醒线程的 Run Loop。</p>

<h4>Timer</h4>

<p>Timer 就是我们平时使用的 NSTimer，它实际上是对 CFRunLoopTimerRef 进行了封装，当我们将其加入 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行对应的回调函数。</p>

<p>假如 Timer 被设置为只触发一次，其触发后会从Run Loop中移除，假如 Timer 被设置为循环触发时，会一直保存在当前Run Loop中，直到调用invalidated方法。</p>

<h4>Observer</h4>

<p>Run Loop 的 Observer(CFRunLoopObserverRef) 会观察 Run Loop 的运行状态，对于不同的状态执行不同的回调函数，Run Loop 的状态有以下几种:</p>

<ul>
<li>Run Loop 进入的时候</li>
<li>Run Loop 即将处理一个Timer的时候</li>
<li>Run Loop 即将处理一个Input Source的时候</li>
<li>Run Loop 即将进入休眠的时候</li>
<li>Run Loop 刚从休眠中被被唤醒的时候</li>
<li>Run Loop 即将退出的时候</li>
</ul>


<p>Observer 同 Timer 类似，在被设置为只触发一次，其触发后会从Run Loop中移除，假如被设置为循环触发时，会一直保存在当前Run Loop中。</p>

<h3>Run Loop 运行机制</h3>

<p>Run Loop 是用来接收事件的一个循环，其生命周期如下：</p>

<ol>
<li>通知观察者 Run Loop已经启动</li>
<li>通知观察者 Timer即将被触发</li>
<li>通知观察者即将触发 Source0 事件</li>
<li>启动 Source0 事件</li>
<li>如果 Source1 准备好并处于等待状态，立即处理，并进入步骤9。</li>
<li>通知观察者线程进入休眠</li>
<li>将线程置于休眠直到任一下面的事件发生：

<ul>
<li>某一事件到达基于 Port 的 Source</li>
<li>定时器启动</li>
<li>Run Loop设置的时间已经超时</li>
<li>Run Loop被显式唤醒</li>
</ul>
</li>
<li>通知观察者线程将被唤醒。</li>
<li>处理未处理的事件:

<ul>
<li>如果用户定义的定时器启动，处理定时器事,进入步骤2</li>
<li>如果 Source1 启动，传递相应的消息</li>
<li>如果 Run Loop 被显式唤醒而且时间还没超时,进入步骤2</li>
</ul>
</li>
<li>通知观察者 Run Loop 结束。</li>
</ol>


<p>上述步骤中，2-9 处于一个 while 循环中。</p>

<h3>自定义 input source</h3>

<h4>Source0</h4>

<p>我们首先定义一个 Source：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoopSourceContext context = {0,(__bridge void *)(self), NULL, NULL, NULL, NULL, NULL, NULL, NULL, &runLoopSourceFired};
</span><span class='line'>    
</span><span class='line'>self.inputSource = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &context);</span></code></pre></td></tr></table></div></figure>


<p>其中 context 里面的最后一个参数表示 source 触发时候的回调函数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void runLoopSourceFired(void *info)
</span><span class='line'>{
</span><span class='line'>    NSLog(@"source0 Fired");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>之后我们建立并开启一个线程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(p_threadWillEnter) object:nil];
</span><span class='line'>[self.thread start];</span></code></pre></td></tr></table></div></figure>


<p>在这个线程里我们执行如下方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)p_threadWillEnter{
</span><span class='line'>
</span><span class='line'>    @autoreleasepool {
</span><span class='line'>     
</span><span class='line'>        CFRunLoopRef currentRunloop = CFRunLoopGetCurrent();
</span><span class='line'>        
</span><span class='line'>        self.backgroundRunloop = currentRunloop;
</span><span class='line'>        
</span><span class='line'>        CFRunLoopAddSource(currentRunloop, self.inputSource, kCFRunLoopDefaultMode);//添加 source0 到当前线程的 Run Loop 里
</span><span class='line'>        
</span><span class='line'>        do {
</span><span class='line'>            [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];//开启 Run Loop
</span><span class='line'>        } while (YES);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>之后假如有事件发生，我们需要通知辅助线程，执行 source0 回调:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (IBAction)buttonDidClicked:(id)sender {
</span><span class='line'>    
</span><span class='line'>    CFRunLoopSourceSignal(self.inputSource); //将该 source 标记为待处理
</span><span class='line'>    
</span><span class='line'>    CFRunLoopWakeUp(self.backgroundRunloop); //唤醒辅助线程
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这样，每按一下按钮，我们就会看到后台线程被唤醒，并执行了 source0 的回调，打印出了 “source0 Fired”。</p>

<h4>Source1 (Port-based Source)</h4>

<p>首先定义一个 NSPort</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  self.mainThreadPort = [NSPort port];</span></code></pre></td></tr></table></div></figure>


<p>之后设置处理该 port 接收事件的 delegate</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   self.mainThreadPort.delegate = self;</span></code></pre></td></tr></table></div></figure>


<p>把该 port 加入到 Run Loop 里,并开启 Run Loop</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[NSRunLoop currentRunLoop] addPort:self.mainThreadPort forMode:NSDefaultRunLoopMode];
</span><span class='line'>[[NSRunLoop currentRunLoop] run];</span></code></pre></td></tr></table></div></figure>


<p>实现 port 的 delegate 方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)handlePortMessage:(NSPortMessage *)message{
</span><span class='line'>
</span><span class='line'>    UInt32 msid = [message msgid];
</span><span class='line'>    
</span><span class='line'>    NSLog(@"msid == %d",msid);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>创建新的线程和该线程的 Port</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.backgroundThread = [[NSThread alloc] initWithTarget:self selector:@selector(p_threadWillEnter) object:nil];
</span><span class='line'>self.backgroundThreadPort = [NSPort port];
</span><span class='line'>self.backgroundThreadPort.delegate = self;</span></code></pre></td></tr></table></div></figure>


<p>开启该线程的 Run Loop</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)p_threadWillEnter{
</span><span class='line'>    
</span><span class='line'>    @autoreleasepool {
</span><span class='line'>        
</span><span class='line'>        NSRunLoop *runloop = [NSRunLoop currentRunLoop];
</span><span class='line'>        
</span><span class='line'>        [runloop addPort:self.backgroundThreadPort forMode:NSDefaultRunLoopMode];
</span><span class='line'>        
</span><span class='line'>        do{
</span><span class='line'>            [runloop runMode:NSDefaultRunLoopMode
</span><span class='line'>                  beforeDate:[NSDate distantFuture]];
</span><span class='line'>        }while (YES);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从 backgroundThread 向 mainThread 发送信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (IBAction)buttonClicked:(id)sender {
</span><span class='line'>    
</span><span class='line'>    NSPortMessage* messageObj = [[NSPortMessage alloc] initWithSendPort:self.mainThreadPort
</span><span class='line'>                                                            receivePort:self.backgroundThreadPort components:nil];
</span><span class='line'>    if (messageObj){
</span><span class='line'>        [messageObj setMsgid:150];
</span><span class='line'>        [messageObj sendBeforeDate:[NSDate date]];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这样每次按按钮，就会看到 <code>- (void)handlePortMessage:(NSPortMessage *)message</code> 回调方法被执行了，实现了线程间基于 Port 的通信。注意这个代码时运行在 OS X 上的，因为 iOS 里面 没有 <code>NSPortMessage</code>。</p>

<h3>参考资料</h3>

<ol>
<li><p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">Run Loops</a></p></li>
<li><p><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解 RunLoop</a></p></li>
<li><p><a href="http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-%5B%3F%5D-:shi-yao-shi-run-loop%3F/">走进Run Loop的世界 (一)</a></p></li>
<li><p><a href="http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-er-:ru-he-pei-zhi-run-loop-sources/">走进Run Loop的世界 (二)</a></p></li>
<li><p><a href="http://www.dreamingwish.com/article/ios-multithread-program-runloop-the.html">iOS多线程编程指南（三）Run Loop</a></p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/23/ios-zhong-xian-cheng-tong-bu-de-%5B%3F%5D-xie-fang-fa/">iOS 中线程同步的一些方法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-23T15:21:04+08:00" pubdate data-updated="true">Oct 23<span>rd</span>, 2015</time>
        
         | <a href="/blog/2015/10/23/ios-zhong-xian-cheng-tong-bu-de-%5B%3F%5D-xie-fang-fa/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>目录</h3>

<ol>
<li>使用串行队列</li>
<li>使用 dispatch_group</li>
<li>使用 dispatch_barrier</li>
<li>使用 dispatch_semaphore</li>
</ol>


<h3>串行队列</h3>

<p>使用串行队列，对于一个资源，同一时刻只有一个任务（线程）访问，这样就避免了资源竞争，实现了资源的同步。我们可以通过 NSOperationQueue 或 dispatch queue来实现串行队列。</p>

<ul>
<li><p>NSOperationQueue</p>

<p> 创建一个    NSOperationQueue 队列，然后将该队列的最大并发数设置为 1，就是一个串行队列。</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSOperationQueue</span> <span class="o">*</span> <span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">queue</span><span class="p">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//每次只执行一个任务</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">count</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation:</span> <span class="p">[</span><span class="n">NSBlockOperation</span> <span class="nl">blockOperationWithBlock:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="p">]];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>dispatch queue
dispatch queue 也分串行队列和并发队列，我们这里需要创建一个串行队列。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">serialQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.ghren.MultiThread.test&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span> <span class="c1">//生成一个串行队列</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">count</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span><span class="c1">//向该串行队列中添加任务</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>使用 dispatch_group</h3>

<p>dispatch_group 可以把很多个任务加入到一个组中，然后等组中所有的任务都执行完毕，再去执行新的任务，同步的操作就在这新的任务中实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">count</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
</span><span class='line'>        <span class="p">});</span><span class="c1">//把任务添加到组中</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">dispatch_group_wait</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span><span class="c1">//阻塞当前线程，一直到组中任务完成</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;done&quot;</span><span class="p">);</span> <span class="c1">//数据同步点</span>
</span></code></pre></td></tr></table></div></figure>


<h3>使用 dispatch_barrier</h3>

<p>假如有这样一个情况，先要执行一组并发的任务，然后在执行一个基于这组并发任务的任务，然后再执行另外一组基于这个任务的并发任务，这种情况虽然也可以通过 dispatch_group 来实现， 但是 GCD 提供了另外一个很优雅的方法，就是 dispatch_barrier,要注意的是对于串行队列使用 dispatch_barrier 意义并不大，因为所有的任务本来就是串行执行的，对于全局的并发队列 <code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code> , dispatch_barrier 也不会生效，所以 dispatch_barrier 一般使用在 自定义的全局并发队列里</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="n">dispatch_queue_t</span> <span class="n">concurrentQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.ghren.MultiThread.concurrent&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span> <span class="c1">//生成一个并发队列, dispatch_barrier 对于全局并发队列并不起作用，所以要用在自己创建的并发队列里</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">count</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="p">}</span> <span class="c1">// 向并发队列里添加任务</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;do something&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span><span class="c1">//同步点</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">count</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span><span class="n">count</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="p">}</span><span class="c1">//向并发队列里添加新的任务</span>
</span></code></pre></td></tr></table></div></figure>


<h3>使用 dispatch_semaphore</h3>

<p>dispatch_semaphore 就是传说中的信号量。其基本原理是，我们可以创建一个信号量，这个信号量有一个值，来表示目前信号量总数有多少，比如我们可以创建一个初始值为 2 的信号量，然后当我们执行一个任务的时候，就消耗一个信号量，信号量总数会减 1 ，当信号量为 0 的时候，即将执行的任务将会被阻塞，然后一直等到超时或信号量又大于0 为止，当我们在一个任务执行完毕的时候，可以为信号量的总量加 1 ，当信号量从 0 变成 1 的时候，等待信号量的任务就会执行下去，通过这个机制，我们可以实现数据的同步。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_semaphore_t</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="n">dispatch_semaphore_create</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_time_t</span> <span class="n">time</span> <span class="o">=</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span><span class="n">NSEC_PER_SEC</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;task will begin&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_after</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;task is done&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">});</span><span class="c1">//3 秒之后在全局并发队列里添加一个任务，任务执行完毕之后，增加一个信号量</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span><span class="c1">//当前线程处于阻塞状态，直到信号量不为0</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;start another task&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/19/reactivecocoa-xue-xi-zi-liao/">ReactiveCocoa 学习资料</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-08-19T17:58:36+08:00" pubdate data-updated="true">Aug 19<span>th</span>, 2015</time>
        
         | <a href="/blog/2015/08/19/reactivecocoa-xue-xi-zi-liao/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/201508191805.png" alt="" /></p>

<ol>
<li><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">官方地址（github）</a></p></li>
<li><p><a href="http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html">ReactiveCocoa与Functional Reactive Programming</a></p></li>
<li><p><a href="http://limboy.me/ios/2013/12/27/reactivecocoa-2.html">说说ReactiveCocoa 2</a></p></li>
<li><p><a href="http://limboy.me/ios/2014/06/06/deep-into-reactivecocoa2.html">ReactiveCocoa2实战</a></p></li>
<li><p><a href="http://nshipster.cn/reactivecocoa/">Reactive​Cocoa-NSHipster</a></p></li>
<li><p><a href="http://yulingtianxia.com/blog/2014/07/29/reactivecocoa/">ReactiveCocoa学习笔记</a></p></li>
<li><p><a href="http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part1">ReactiveCocoa入门教程——第一部分</a></p></li>
<li><p><a href="http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part2">ReactiveCocoa入门教程——第二部分</a></p></li>
<li><p><a href="http://southpeak.github.io/blog/2014/09/21/zai-reactivecocoazhong-jiang-%5B%3F%5D-ge-viewmodelbang-ding-dao-uitableviewshang/">在ReactiveCocoa中将一个ViewModel绑定到UITableView上</a></p></li>
<li><p><a href="http://blog.devtang.com/blog/2014/02/11/reactivecocoa-introduction/">ReactiveCocoa &ndash; iOS开发的新框架</a></p></li>
<li><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_0_overview/">Reactive Cocoa Tutorial [0] = Overview</a></p></li>
<li><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/">Reactive Cocoa Tutorial [1] = 神奇的Macros</a></p></li>
<li><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_2_racstream/">Reactive Cocoa Tutorial [2] = 百变RACStream</a>;</p></li>
<li><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/">Reactive Cocoa Tutorial [3] = RACSignal的巧克力工厂</a></p></li>
<li><p><a href="http://blog.sunnyxx.com/2014/04/19/rac_4_filters/">Reactive Cocoa Tutorial [4] = 只取所需的Filters</a></p></li>
</ol>


<p>学习顺序为 2，3，4，7，8，11，12，13，14，15，其他。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/27/guan-yu-uilocalnotification-de-ji-ge-wen-ti/">关于 UILocalNotification 的几个问题</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-05-27T18:47:25+08:00" pubdate data-updated="true">May 27<span>th</span>, 2015</time>
        
         | <a href="/blog/2015/05/27/guan-yu-uilocalnotification-de-ji-ge-wen-ti/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/201505271852.png" alt="" /></p>

<h3>问题</h3>

<ol>
<li><p>如何修改已经启动的<code>UILocalNotification</code></p></li>
<li><p>为何<code>cancelAllLocalNotifications</code>方法调用完毕之后并不生效</p></li>
</ol>


<h3>回答</h3>

<ol>
<li><p>停止已经启动的<code>UILocalNotification</code>，创建一个新的<code>UILocalNotification</code>并启动，直接修改已经启动的<code>UILocalNotification</code>是不生效的，因为你在<code>[[UIApplication sharedApplication] scheduleLocalNotification:notification]</code>的时候，复制了一个当前的notification，并提交到系统的推送队列上，假如不提交的话，系统是不认识这个notification的。</p></li>
<li><p>执行完 <code>cancelAllLocalNotifications</code> 后，你再打印<code>[UIApplication sharedApplication].scheduledLocalNotifications</code>,发现其并不为空,stackoverflow 上有人说这个方法不是同步执行的，只会在当前的 run loop 结束之后生效,有人说可以通过</p></li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">].</span><span class="n">scheduledLocalNotifications</span> <span class="o">=</span> <span class="nb">nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>的方法使其立即生效，测试发现并没有什么作用，真正有用的方法还是 stackoverflow 上一个开发者提出的变通方法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="n">cancelAllLocalNotifications</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">((</span><span class="n">count</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="n">scheduledLocalNotifications</span><span class="p">]</span> <span class="n">count</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Remaining notificaitons to cancel: %lu&quot;</span><span class="p">,(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">count</span><span class="p">);</span>
</span><span class='line'>        <span class="p">[</span><span class="n">NSThread</span> <span class="nl">sleepForTimeInterval:</span><span class="mf">.01f</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于问题1，有时候在 <code>[[UIApplication sharedApplication] cancelLocalNotification:notification]</code>的时候可能会发现并没有立即cancel掉，也可以采用这样的方法，在 cancel 完之后 执行下 <code>[NSThread sleepForTimeInterval:.01f]</code>;</p>

<h3>参考资料</h3>

<ol>
<li><p><a href="http://stackoverflow.com/questions/25948037/ios-8-uiapplication-sharedapplication-scheduledlocalnotifications-empty">scheduledLocalNotifications</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/13163535/cancelalllocalnotifications-not-working-on-iphone-3gs">cancelAllLocalNotifications</a></p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/10/ios8-zhong-de-shi-shi-mo-hu-view%5Bnil%5Duivisualeffectview/">iOS8 中的实时模糊View－UIVisualEffectView</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-05-10T13:08:00+08:00" pubdate data-updated="true">May 10<span>th</span>, 2015</time>
        
         | <a href="/blog/2015/05/10/ios8-zhong-de-shi-shi-mo-hu-view%5Bnil%5Duivisualeffectview/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/201505101313.png" alt="" /></p>

<h3>介绍</h3>

<p>在iOS7 以后，整个扁平化的 iOS 界面都大量采用了高斯模糊的效果来展示层次，比如在主界面上从底面上划出来 的控制面板，或者从顶部向下划出来的通知栏界面，都实时模糊了主界面背景，在 iOS7 的时候我们总共有 3.5 个办法来实现这些效果：</p>

<ol>
<li>利用苹果开源的 UIImage+ImageEffects</li>
<li>利用 GPUImage 的高斯模糊滤镜</li>
<li>利用CoreImage 的高斯模糊滤镜</li>
</ol>


<p>在 iOS7 初期的时候还有人使用 UIToolBar 覆盖在 superView 上的方法来实现，但是后来这个方法失效了，所以只能算半个。不过到了 iOS8，苹果提供了一个非常好用的方案－UIVisualEffectView。</p>

<p>UIVisualEffectView 是 UIView 的子类，因此使用的时候就是实例化一个 UIVisualEffectView，然后添加到superView 上就 OK 了。 That‘s it，就这么简单。</p>

<p>UIVisualEffectView 有两种效果，一种是 UIBlurEffect，即高斯模糊效果，一种是 UIVibrancyEffect，这种效果能把背景 View 和 当前 View 混合起来，通常使用的时候要在模糊后的 View 上 显示一些内容的话，就要在 UIBlurEffect 的 View 上 再添加一层 UIVibrancyEffect，这样可以使整个显示效果更舒适一点，下面这张图展示了在背景图片完全相同的情况下使用和不使用 Vibrancy 的不同:</p>

<p><img src="/images/10310Q192-19.png" alt="" /></p>

<h3>代码</h3>

<p>Objectivie-C</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//初始化一个 UIVisualEffect，UIBlurEffect 是 UIVisualEffect 的子类</span>
</span><span class='line'><span class="n">UIBlurEffect</span> <span class="o">*</span><span class="n">blurEffect</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBlurEffect</span> <span class="nl">effectWithStyle:</span><span class="n">UIBlurEffectStyleExtraLight</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//初始化 模糊效果的 UIVisualEffectView</span>
</span><span class='line'><span class="n">UIVisualEffectView</span> <span class="o">*</span> <span class="n">blurEffectView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIVisualEffectView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithEffect:</span><span class="n">blurEffect</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//设置 blurEffectView 的 frame</span>
</span><span class='line'><span class="n">blurEffectView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//添加 blurEffectView 到 self.View 上,如果只是做模糊效果，那么到这一步已经完了</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview:</span><span class="n">blurEffectView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//初始化 Vibrancy 类型的 UIVisualEffect，vibrancyEffect 也是UIVisualEffect 的子类，而且初始化这个 Effect 需要用到 blurEffect，我们就还用上面的好了，假如重新初始化一个 blurEffect，要注意这个新的 blurEffect 的 style 要和上面的保持一致，不然就实现不了 Vibrancy效果</span>
</span><span class='line'><span class="n">UIVibrancyEffect</span> <span class="o">*</span><span class="n">vibrancyEffect</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIVibrancyEffect</span> <span class="nl">effectForBlurEffect:</span><span class="n">blurEffect</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//初始化 Vibrancy 效果的 UIVisualEffectView</span>
</span><span class='line'><span class="n">UIVisualEffectView</span> <span class="o">*</span><span class="n">vibrancyEffectView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIVisualEffectView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithEffect:</span><span class="n">vibrancyEffect</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//设置 vibrancyEffectView 的frame</span>
</span><span class='line'><span class="n">vibrancyEffectView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">blurEffectView</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">//注意是 blurEffectView.contentView. 苹果官方注释说了  Do not add subviews directly to UIVisualEffectView, use this view instead</span>
</span><span class='line'><span class="p">[</span><span class="n">blurEffectView</span><span class="p">.</span><span class="n">contentView</span> <span class="nl">addSubview:</span><span class="n">vibrancyEffectView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">//初始化一个 label</span>
</span><span class='line'><span class="n">UILabel</span> <span class="o">*</span><span class="n">label</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UILabel</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="n">vibrancyEffectView</span><span class="p">.</span><span class="n">bounds</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">label</span><span class="p">.</span><span class="n">textAlignment</span> <span class="o">=</span> <span class="n">NSTextAlignmentCenter</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">@&quot;Live long and Prosper&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">label</span><span class="p">.</span><span class="n">font</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIFont</span> <span class="nl">fontWithName:</span><span class="s">@&quot;SnellRoundhand-Black&quot;</span> <span class="nl">size:</span><span class="mf">29.0f</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//添加 label</span>
</span><span class='line'><span class="p">[</span><span class="n">vibrancyEffectView</span><span class="p">.</span><span class="n">contentView</span> <span class="nl">addSubview:</span><span class="n">label</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考资料</h3>

<ol>
<li><a href="http://www.raywenderlich.com/84043/ios-8-visual-effects-tutorial">UIVisualEffectView Tutorial</a></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/12/swift-yu-objective-c-hun-bian-ji-ru-he-diao-yong-cocoapods/">Swift 与 Objective-C 混编及如何调用 Cocoapods</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-04-12T11:42:05+08:00" pubdate data-updated="true">Apr 12<span>th</span>, 2015</time>
        
         | <a href="/blog/2015/04/12/swift-yu-objective-c-hun-bian-ji-ru-he-diao-yong-cocoapods/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/201504121200.png" alt="" /></p>

<h3>目录</h3>

<ol>
<li>Swift 与 Objectve-C 混编</li>
<li>Swift 如何使用 Objective-C 的 cocoapods</li>
</ol>


<h3>Swift 与 Objectve-C 混编</h3>

<h4>Swift 文件里使用 Objective-C 类</h4>

<p>无论是在 Swift 工程中新建 Objectve-C 的类，还是在 Objective-C 中新建 Swift 的类，Xcode 都会提示 <code>Would you like to configure an Objective-C bridging header?</code> ，选择是，就会新建一个Bridging 的文件，文件的名称一般是 <code>ProjectName-Bridging-Header.h</code>,比如项目名称是 <code>Cat</code>，那么名称就会是<code>Cat-Bridging-Header.h</code>，然后在这个文件里引用 Swift 需要用到的 Objective-C 的头文件，比如</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &quot;GHCatView.h&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么就在 Swift 的类里使用 Objective-C 类了.</p>

<h4>Objective-C 文件里使用 Swift 类</h4>

<p>直接在.m 文件里</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &quot;Cat-swift.h&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Swift 如何使用 Objective-C 的 Cocoapods</h3>

<p>通过 cocoapods 使用第三方的 Objective-C 的组件的时候，在<code>ProjectName-Bridging-Header.h</code>里面引入相关的头文件，比如你要使用 Mantle，就可以</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;Mantle/Mantle.h&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来就可以在 Swift 的文件里使用了</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/07/calayer-%5B%3F%5D/">CALayer(一)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-04-07T11:38:10+08:00" pubdate data-updated="true">Apr 7<span>th</span>, 2015</time>
        
         | <a href="/blog/2015/04/07/calayer-%5B%3F%5D/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/201504071154.png" alt="" /></p>

<h3>目录</h3>

<ol>
<li>简介</li>
<li>contents</li>
<li>参考资料</li>
</ol>


<h3>简介</h3>

<p>CALayer（图层） 可以看作是UIView的内部实现，每一个 UIView 都有一个 名称为layer 的属性，我们看到的view的具体内容都是这个layer展示的，UIView 对 CALayer 做了一些封装，并在此基础之上提供了和用户交互的一系列方法。和 UIVIew 一样，CALayer 也有相同的层级关系，每一个CALyer 对象都可以增加 sublayer。通过 CALayer 我们可以实现一些 UIView 无法实现的效果，比如阴影，圆角，边框等，而且还可以实现很多 UIView 无法实现的非常炫酷的动画。</p>

<h3>contents</h3>

<p>CALayer 有一个 id 类型的contents的属性，这个 contents 负责显示具体的内容，比如一张图片等，这里要注意假如要为 contents 设置一张图片的话，不能用UIImage，用UIImage的话，显示出来的图层上面什么都没有。要用 CGImageRef 类型的值，但 CGImageRef 不是Cocoa 对象，而是一个Core Foundation类型，所以要通过 toll-free bridging 来转换一下，比如</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">layer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="kt">id</span><span class="p">)</span><span class="n">image</span><span class="p">.</span><span class="n">CGImage</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>除了给 contents 赋值 CGImageRef 外，还可以用 Core Graphics 直接绘制的方法来设置 contents 的内容，主要是通过集成 UIView 并实现 <code>-drawRect:</code>方法来实现的。</p>

<p>关于 contents 显示的具体方式，CALayer 有一些很有用的属性可以设置，比如：</p>

<ul>
<li>contentsGravity</li>
<li>contentsScale</li>
<li>maskToBounds</li>
<li>contentsRect</li>
<li>contentsCenter</li>
</ul>


<h4>contentsGravity</h4>

<p>contentsGravity 类似于 UIView 中的 contentMode 属性，就是决定 contents 在图层的边界中怎么对齐，比如是居中还是靠上等，contentsGravity可选的常量值主要有：</p>

<ul>
<li>kCAGravityCenter</li>
<li>kCAGravityTop</li>
<li>kCAGravityBottom</li>
<li>kCAGravityLeft</li>
<li>kCAGravityRight</li>
<li>kCAGravityTopLeft</li>
<li>kCAGravityTopRight</li>
<li>kCAGravityBottomLeft</li>
<li>kCAGravityBottomRight</li>
<li>kCAGravityResize</li>
<li>kCAGravityResizeAspect</li>
<li>kCAGravityResizeAspectFill</li>
</ul>


<p>我们可以从名字看出它们的作用。</p>

<h4>contentsScale</h4>

<p>contentsScale 主要用来告诉系统在绘制 contents 的时候一个点绘制几个像素，比如以前的非 Retina 屏幕的时候，就是1，现在的 Phone6 plus 是3，别的 Retina 屏幕就是2，因此当我们是 Retina 屏幕的时候在设置 图层的 contents 的时候不要忘了加上</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">layer</span><span class="p">.</span><span class="n">contentsScale</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIScreen</span> <span class="n">mainScreen</span><span class="p">]</span> <span class="n">scale</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h4>maskToBounds</h4>

<p>作用和 UIView 的 clipsToBounds 类似，就是决定是否显示超出该图层边界的内容，要注意如果该属性要设置为 YES 的话，再设置阴影效果是不起作用的，因为阴影超出了图层的边界。</p>

<h4>contentsRect</h4>

<p>contentsRect 能让 CALayer 只显示 contents 的一部分，它的范围在 0 到 1 之间,比如说设置如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">layer</span><span class="p">.</span><span class="n">contentsRect</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么实际显示在layer上的就是 contents 的左上部分。这个方法在一些地方会很有用，比如 cocosd 中精灵纹理的图片就是载入一张拼合了很多图片的大图，然后在需要的时候通过这个方法对不同的区域进行切割。</p>

<h4>contentsCenter</h4>

<p>contentsCenter是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域，它的范围在 0 到 1 之间，只有 contents 大小和图层大小不一致时，才发挥作用，系统默认的 contentsCenter 的大小为 {0,0,1,1}, 即 contents 会被均匀的拉伸，如果我们设置:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">layer</span><span class="p">.</span><span class="n">contentsCenter</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么其均匀拉伸的区域就是中间的区域，四个角的地方保持不变，借用一张图表示如下:</p>

<p><img src="/images/contentsCenter.png" alt="" /></p>

<h3>参考资料</h3>

<ol>
<li><p><a href="http://zsisme.gitbooks.io/ios-/content/chapter2/the-contents-image.html">contents 属性</a></p></li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CALayer_class/index.html">CALayer</a></p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/23/cikernel-de-xue-xi/">CIKernel 的学习</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-23T21:39:36+08:00" pubdate data-updated="true">Mar 23<span>rd</span>, 2015</time>
        
         | <a href="/blog/2015/03/23/cikernel-de-xue-xi/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/201503232142.png" alt="" /></p>

<p>在使用 Core Image 的时候，Apple 提供的效果有时候无法满足我们的需求，我们希望能实现自己的滤镜，这个时候我们可以用 CIKernel。CIKernel 是 iOS8 的时候出现的，它是一种类似于 OpenGL 着色器的处理程序。苹果提供了一系列的函数和数据类型供我们使用它。具体参见<a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CIKernelLangRef/ci_gslang_ext.html">Core Image Kernel Language</a>。</p>

<h3>子类</h3>

<p>CIKernel 有两个子类：<code>CIColorKernel</code>和<code>CIWarpKernel</code>。</p>

<h3>初始化</h3>

<p>我们通过一个 <code>NSString</code> 来初始化一个 <code>CIKernel</code>；</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>   <span class="n">NSString</span> <span class="o">*</span><span class="n">kernelString</span> <span class="o">=</span>
</span><span class='line'>    <span class="s">@&quot;kernel vec4 moveUpTwoPixels (sampler image) {</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>    <span class="s">@&quot;  vec2 dc = destCoord();</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>    <span class="s">@&quot;  vec2 offset = vec2(0.0, 2.0);</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>    <span class="s">@&quot;  return sample (image, samplerTransform (image, dc + offset));</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>    <span class="s">@&quot;}&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CIKernel</span> <span class="o">*</span><span class="n">kernel</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIKernel</span> <span class="nl">kernelWithString:</span><span class="n">kernelString</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>使用</h3>

<p>使用的时候可以这么用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;flower&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">CIImage</span> <span class="o">*</span><span class="n">inputImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIImage</span> <span class="nl">imageWithCGImage:</span><span class="n">image</span><span class="p">.</span><span class="n">CGImage</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">CIImage</span> <span class="o">*</span><span class="n">outImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">kernel</span> <span class="nl">applyWithExtent:</span><span class="n">inputImage</span><span class="p">.</span><span class="n">extent</span> <span class="nl">roiCallback:</span><span class="o">^</span><span class="n">CGRect</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">CGRect</span> <span class="n">rect</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">inputImage</span><span class="p">.</span><span class="n">extent</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="nl">arguments:</span><span class="err">@</span><span class="p">[</span><span class="n">inputImage</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，核心代码为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">kernel</span> <span class="n">vec4</span> <span class="nf">moveUpTwoPixels</span> <span class="p">(</span><span class="n">sampler</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">vec2</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">destCoord</span><span class="p">();</span>
</span><span class='line'>    <span class="n">vec2</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">sample</span> <span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">samplerTransform</span> <span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">dc</span> <span class="o">+</span> <span class="n">offset</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个 函数，其中返回值 vec4 是一个 由 float 构成的向量，苹果在文档里说这个函数的返回值必须是这种类型。函数的名称 叫 <code>moveUpTwoPixels</code>,函数的参数为一个 sampler 类型，对于我们的程序来说，这个参数要求我们传递一个CIImage，这里的参数也可以有多个，对应着</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">CIImage</span> <span class="o">*</span><span class="p">)</span><span class="nf">applyWithExtent:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">extent</span>
</span><span class='line'>                   <span class="nf">arguments:</span><span class="p">(</span><span class="n">NSArray</span><span class="o">*</span><span class="p">)</span><span class="nv">args</span>
</span></code></pre></td></tr></table></div></figure>


<p> 方法里的 args 的参数。</p>

<h3>CIColorKernel</h3>

<p>我们也可以创建一个CIColorKernel:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">kernelString</span> <span class="o">=</span>
</span><span class='line'>    <span class="s">@&quot;kernel vec4 chromaKey( __sample s, __color c, float threshold ) { </span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>    <span class="s">@&quot;  vec4 diff = s.rgba - c;</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>    <span class="s">@&quot;  float distance = length( diff );</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>    <span class="s">@&quot;  float alpha = compare( distance - threshold, 0.0, 0.5 );</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>    <span class="s">@&quot;  return vec4( s.rgb, alpha ); </span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>    <span class="s">@&quot;}&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">CIColorKernel</span> <span class="o">*</span><span class="n">kernel</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIColorKernel</span> <span class="nl">kernelWithString:</span><span class="n">kernelString</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用的时候:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;flower&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">CIImage</span> <span class="o">*</span><span class="n">inputImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIImage</span> <span class="nl">imageWithCGImage:</span><span class="n">image</span><span class="p">.</span><span class="n">CGImage</span><span class="p">];</span>
</span><span class='line'><span class="n">CIImage</span> <span class="o">*</span><span class="n">outImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">kernel</span> <span class="nl">applyWithExtent:</span><span class="n">inputImage</span><span class="p">.</span><span class="n">extent</span> <span class="nl">arguments:</span><span class="err">@</span><span class="p">[</span><span class="n">inputImage</span><span class="p">,[</span><span class="n">CIColor</span> <span class="nl">colorWithRed:</span><span class="mf">0.0f</span> <span class="nl">green:</span><span class="mf">1.0f</span> <span class="nl">blue:</span><span class="mf">0.0f</span><span class="p">],</span><span class="err">@</span><span class="mf">0.0f</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>更多</h3>

<p> 进一步学习中。。。</p>

<h3>参考资料</h3>

<ol>
<li><p><a href="http://www.shinobicontrols.com/blog/posts/2014/08/19/ios8-day-by-day-day-19-coreimage-kernels">iOS8 Day-by-Day :: Day 19 :: CoreImage Kernels</a></p></li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CIKernelLangRef/ci_gslang_ext.html#//apple_ref/doc/uid/TP40004397-CH206-TPXREF101">Core Image Kernel Language</a></p></li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185">About Core Image</a></p></li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_advanced_concepts/ci.advanced_concepts.html#//apple_ref/doc/uid/TP30001185-CH9-SW1">What You Need to Know Before Writing a Custom Filter</a></p></li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_custom_filters/ci_custom_filters.html#//apple_ref/doc/uid/TP30001185-CH6-TPXREF101">Creating Custom Filters</a></p></li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_image_units/ci_image_units.html#//apple_ref/doc/uid/TP30001185-CH7-SW12">Packaging and Loading Image Units</a></p></li>
<li><p><a href="http://www.cocoachina.com/b/?p=174#more-174">如何制作Core Image滤镜插件</a></p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/31/touch-id-de-shi-yong/">Touch ID 的使用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-31T19:41:53+08:00" pubdate data-updated="true">Jan 31<span>st</span>, 2015</time>
        
         | <a href="/blog/2015/01/31/touch-id-de-shi-yong/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/201501312106.png" alt="" /></p>

<h3>目录</h3>

<ol>
<li>序</li>
<li>思路</li>
<li>具体实现</li>
<li>参考资料</li>
</ol>


<h3>序</h3>

<p>iOS8，苹果开放了 Touch ID 的 SDK，苹果自身的 Connect、 Health 应用都使用了 Touch ID 来进行解锁登录，一些第三方应用比如 1Password 也使用了Touch ID 的登录方式，那么对于我们自己的应用，如何来使用 Touch ID 这个优秀的工具呢？下面是个人的一些想法和实践。</p>

<h3>思路</h3>

<p>既然使用 Touch ID 来自动登录，那么一定要把用户的的账号密码信息存储起来，然后在通过 Touch ID 验证通过的时候来获取到存储的用户密码，进行登录。因为密码的安全性很重要，所以可以把密码存储到 Keychain 里，如果觉得单独的存储字符串还是不够安全，可以在存储之前做一层 AES 的加密。流程分两部分，一部分为配置Touch ID,一部分为使用 Touch ID。流程如下</p>

<h4>配置 Touch ID</h4>

<ol>
<li>用户正常登录</li>
<li>登陆成功之后，通过 Keychain 把用户名和密码存储起来</li>
<li>在设置里面面增加一项，启用 Touch ID，当用户选择启用 Touch ID 的时候，把该用户名存入到 NSUserDefaults 里。</li>
</ol>


<h4>使用Touch ID</h4>

<ol>
<li>用户输入用户名</li>
<li>用户点击密码输入框</li>
<li>先检查设备是否具备 Touch ID 的功能，然后通过 NSUserDefaults 查询该用户是否启用了 Touch ID 以及在 Keychain 中是否能获取到该用户信息。</li>
<li>如果以上条件都满足，就弹出 Touch ID 验证的视图</li>
<li>用户 通过 Touch ID 的验证，根据用户输入的用户名在 Keychain里 得到对应的密码，填充到密码框里</li>
<li>登录</li>
</ol>


<h3>具体实现</h3>

<h4>检查设备是否具备 Touch ID 功能</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">canEvaluatePolicy</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">LAContext</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="p">[[</span><span class="n">LAContext</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">success</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// test if we can evaluate the policy, this test will tell us if Touch ID is available and enrolled</span>
</span><span class='line'>    <span class="n">success</span> <span class="o">=</span> <span class="p">[</span><span class="n">context</span> <span class="nl">canEvaluatePolicy:</span> <span class="n">LAPolicyDeviceOwnerAuthenticationWithBiometrics</span> <span class="nl">error:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意 添加 <code>@import LocalAuthentication;</code></p>

<h4>显示 Touch ID 的 UI视图</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">evaluatePolicyWithTitle:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">title</span> <span class="nf">successHandler:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">successHandler</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">LAContext</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="p">[[</span><span class="n">LAContext</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// show the authentication UI with our reason string</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">context</span> <span class="nl">evaluatePolicy:</span><span class="n">LAPolicyDeviceOwnerAuthenticationWithBiometrics</span> <span class="nl">localizedReason:</span><span class="n">title</span> <span class="nl">reply:</span>
</span><span class='line'>     <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">success</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">authenticationError</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>         <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>             <span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span>
</span><span class='line'>             <span class="p">{</span>
</span><span class='line'>                 <span class="k">if</span> <span class="p">(</span><span class="n">successHandler</span><span class="p">)</span>
</span><span class='line'>                 <span class="p">{</span>
</span><span class='line'>                     <span class="n">successHandler</span><span class="p">();</span>
</span><span class='line'>                 <span class="p">}</span>
</span><span class='line'>             <span class="p">}</span>
</span><span class='line'>         <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>     <span class="p">}];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中 title 是用来描述我们使用 Touch ID来做什么的，比如 “解锁 APP” 之类的，successHandler 是 Touch ID 验证通过的回调，我们可以在这里来获取 Keychain 里的用户密码，然后进行登录，比如</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="p">[</span><span class="n">self</span> <span class="nl">evaluatePolicyWithTitle:</span><span class="n">NSLocalizedString</span><span class="p">(</span><span class="s">@&quot;Unlock APP&quot;</span><span class="p">,</span> <span class="nb">nil</span><span class="p">)</span> <span class="nl">successHandler:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>                    <span class="n">self</span><span class="p">.</span><span class="n">pwdTextField</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">passwordFromKeychainWithUsername:</span><span class="n">_userNameTextField</span><span class="p">.</span><span class="n">text</span><span class="p">];</span>
</span><span class='line'>                    <span class="p">[</span><span class="n">self</span> <span class="n">login</span><span class="p">];</span>
</span><span class='line'>                <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<h4>用户名密码的存储</h4>

<p>这里用的 Keychain 是 Justin Williams 封装的 SGKeychain</p>

<p>存储到 Keychain</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">saveToKeyChainWithUsername:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">username</span> <span class="nf">password:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">password</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">SGKeychainItem</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SGKeychainItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">item</span><span class="p">.</span><span class="n">account</span> <span class="o">=</span> <span class="n">username</span><span class="p">;</span>
</span><span class='line'>    <span class="n">item</span><span class="p">.</span><span class="n">service</span> <span class="o">=</span> <span class="s">@&quot;APP&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">item</span><span class="p">.</span><span class="n">secret</span> <span class="o">=</span> <span class="n">password</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">SGKeychain</span> <span class="nl">storeKeychainItem:</span><span class="n">item</span> <span class="nl">completionHandler:</span><span class="o">^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Password successfully created&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Password failed to be created with error: %@&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">.</span><span class="n">description</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从 Keychain 获取密码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">passwordFromKeychainWithUsername:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">username</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">SGKeychainItem</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SGKeychainItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">item</span><span class="p">.</span><span class="n">account</span> <span class="o">=</span> <span class="n">username</span><span class="p">;</span>
</span><span class='line'>    <span class="n">item</span><span class="p">.</span><span class="n">service</span> <span class="o">=</span> <span class="s">@&quot;APP&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Fetch the password</span>
</span><span class='line'>    <span class="p">[</span><span class="n">SGKeychain</span> <span class="nl">populatePasswordForItem:</span><span class="n">item</span> <span class="nl">completionHandler:</span><span class="o">^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;error == %@&quot;</span><span class="p">,</span><span class="n">error</span><span class="p">.</span><span class="n">description</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;password ==%@&quot;</span><span class="p">,</span><span class="n">item</span><span class="p">.</span><span class="n">secret</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">item</span><span class="p">.</span><span class="n">secret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考资料</h3>

<ol>
<li><a href="https://github.com/secondgear/SGKeychain">SGKeychain</a></li>
<li><a href="http://www.cocoachina.com/ios/20141114/10222.html">在iOS 8 SDK中使用Touch ID API</a></li>
<li><a href="http://blog.csdn.net/johnson_puning/article/details/36188255"> iOS8 Touch ID api接口调用</a></li>
</ol>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/24/dispatch-source/">Dispatch Source</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/21/run-loop/">Run Loop</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/23/ios-zhong-xian-cheng-tong-bu-de-%5B%3F%5D-xie-fang-fa/">iOS 中线程同步的一些方法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/19/reactivecocoa-xue-xi-zi-liao/">ReactiveCocoa 学习资料</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/27/guan-yu-uilocalnotification-de-ji-ge-wen-ti/">关于 UILocalNotification 的几个问题</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - ghren -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'alex1212112';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
