<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Summerrose’s Blog]]></title>
  <link href="http://alex1212112.github.io/atom.xml" rel="self"/>
  <link href="http://alex1212112.github.io/"/>
  <updated>2016-03-28T20:58:20+08:00</updated>
  <id>http://alex1212112.github.io/</id>
  <author>
    <name><![CDATA[ghren]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dispatch Source]]></title>
    <link href="http://alex1212112.github.io/blog/2015/11/24/dispatch-source/"/>
    <updated>2015-11-24T00:16:49+08:00</updated>
    <id>http://alex1212112.github.io/blog/2015/11/24/dispatch-source</id>
    <content type="html"><![CDATA[<h3 id="section">目录</h3>
<ol>
  <li>概述</li>
  <li>事件与种类</li>
  <li>使用 Dispatch Source</li>
</ol>

<h3 id="section-1">概述</h3>

<p>iOS 中有两种 Source，一种是 Run Loop Source ,一种是 Dispatch Source。</p>

<p>Source 可以理解为产生事件的地方，Source 产生事件，然后 Source 的回调函数负责 处理这些事件。</p>

<p>在 Run Loop 中， Run Loop Source 产生事件，之后唤醒 Run Loop， Run Loop 便执行该 Source 的回调函数。</p>

<p>Dispatch Source 也会产生一些特定的事件，当这些事件发生的时候，其回调的 block 会自动加入到 对应的 dispatch queue 中。</p>

<h3 id="section-2">事件与种类</h3>

<p>Dispatch Source 监控的事件主要有以下几种：</p>

<ol>
  <li>Timer dispatch sources generate periodic notifications.</li>
  <li>Signal dispatch sources notify you when a UNIX signal arrives.</li>
  <li>Descriptor sources notify you of various file- and socket-based operations, such as:
    <ul>
      <li>When data is available for reading</li>
      <li>When it is possible to write data</li>
      <li>When files are deleted, moved, or renamed in the file system</li>
      <li>When file meta information changes</li>
    </ul>
  </li>
  <li>Process dispatch sources notify you of process-related events, such as:
    <ul>
      <li>When a process exits</li>
      <li>When a process issues a fork or exec type of call</li>
      <li>When a signal is delivered to the process</li>
    </ul>
  </li>
  <li>Mach port dispatch sources notify you of Mach-related events.</li>
  <li>Custom dispatch sources are ones you define and trigger yourself.</li>
</ol>

<p>对应着系统定义的 Dispatch Source 种类：</p>

<ol>
  <li>DISPATCH_SOURCE_TYPE_TIMER 定时器</li>
  <li>DISPATCH_SOURCE_TYPE_SIGNAL 接收到 UNIX 信号</li>
  <li>DISPATCH_SOURCE_TYPE_READ 文件可读</li>
  <li>DISPATCH_SOURCE_TYPE_WRITE 文件可写</li>
  <li>DISPATCH_SOURCE_TYPE_VNODE 文件系统有变更</li>
  <li>DISPATCH_SOURCE_TYPE_PROC 与进程相关的事件</li>
  <li>DISPATCH_SOURCE_TYPE_MACH_SEND  Mach 端口发送事件</li>
  <li>DISPATCH_SOURCE_TYPE_MACH_RECV  Mach 端口接收事件</li>
  <li>DISPATCH_SOURCE_TYPE_DATA_ADD 用户自定义的事件－变量相加</li>
  <li>DISPATCH_SOURCE_TYPE_DATA_OR  用户自定义的事件－变量相或</li>
</ol>

<p>这些事件都是来自于 XNU 内核中，kqueue 是用来处理这些事件的最好的一种方法，Dispatch Source 就是对 kqueue 的封装。</p>

<h3 id="dispatch-source">使用 Dispatch Source</h3>

<p>使用 Dispatch Source 一般分为以下几步：</p>

<ol>
  <li>创建 Dispatch Source</li>
  <li>配置 Dispatch Source</li>
  <li>启动 Dispathc source</li>
  <li>手动或自动发送 Dispatch Source 事件</li>
</ol>

<h4 id="dispatch-source-1">自定义 Dispatch Source</h4>

<p>首先创建并配置 Dispatch Sourcce</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">self.count = 0;
</span><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();
</span><span class="line">self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, queue);//创建 Dispatch Source，种类为DISPATCH_SOURCE_TYPE_DATA_ADD，即获取到的变量会相加
</span><span class="line">
</span><span class="line">
</span><span class="line">dispatch_source_set_event_handler(self.source, ^{
</span><span class="line">
</span><span class="line">    UInt64 value = dispatch_source_get_data(self.source);
</span><span class="line">    
</span><span class="line">    self.count += value;
</span><span class="line">    NSLog(@"n = %ld",(long)self.count);
</span><span class="line">    
</span><span class="line">});//配置 Dispatch Source 的回调 block，即当收到该 Source 事件时候，就把该 block 追加到对应的queue中
</span><span class="line">
</span><span class="line">dispatch_resume(self.source); //启动 Source， Source 默认是 suspend 的，需要手动启动</span></code></pre></td></tr></table></div></figure>

<p>发送 Dispatch Source 事件</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class=""><span class="line">- (IBAction)buttonDidClicked:(id)sender {
</span><span class="line">    
</span><span class="line">    self.count = 0.0;
</span><span class="line">    
</span><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT , 0);
</span><span class="line">    
</span><span class="line">    for (NSInteger i = 0; i &lt; 100; i++) {
</span><span class="line">        
</span><span class="line">        dispatch_async(queue, ^{
</span><span class="line">            
</span><span class="line">            dispatch_source_merge_data(self.source, 1);//发送 Source 事件
</span><span class="line">            sleep(1);
</span><span class="line">            
</span><span class="line">        });
</span><span class="line">    }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>之后，我们点击按钮之后，就会通过全局并发队列 发送 100 次 Source 事件，不过并不会 回调 100 次 回调 Block， 这是因为对应的 队列在接收到 Source 事件之后，假如队列处于空闲状态，就会执行对应的 回调 Block，假如队列处于 busy 状态，该事件就会和后面的一系列同种事件通过一定的方式被合并起来（此例中是按照相加的方式），等到队列空闲的时候再执行。</p>

<h4 id="dispatch-source-timer">Dispatch Source Timer</h4>

<p>利用 Dispatch Source 的 DISPATCH_SOURCE_TYPE_TIMER 类型，我们可以创建一个 跨线程的 定时器（我们平时使用的 NSTimer 是基于 Run Loop 的 timer 事件，只能在对应的线程里触发）</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();
</span><span class="line">self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);//创建一个 timer；
</span><span class="line">dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);//配置 timer，从现在起，每两秒在主线程触发一次，精度为0s
</span><span class="line">dispatch_source_set_event_handler(self.timer, ^{
</span><span class="line">    
</span><span class="line">    NSLog(@"%ld", self.count++);
</span><span class="line">});//timer 触发之后的回调 block
</span><span class="line">
</span><span class="line">dispatch_resume(self.time); //启动 timer</span></code></pre></td></tr></table></div></figure>

<h3 id="section-3">参考资料</h3>
<ol>
  <li>
    <p><a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html">Dispatch Sources</a>;</p>
  </li>
  <li>
    <p><a href="http://www.dreamingwish.com/article/grand-central-dispatch-basic-3.html">GCD入门（三）: Dispatch Sources</a>;</p>
  </li>
  <li>
    <p><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md">Parse的底层多线程处理思路：GCD高级用法</a>;</p>
  </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Run Loop]]></title>
    <link href="http://alex1212112.github.io/blog/2015/11/21/run-loop/"/>
    <updated>2015-11-21T21:17:04+08:00</updated>
    <id>http://alex1212112.github.io/blog/2015/11/21/run-loop</id>
    <content type="html"><![CDATA[<h3 id="section">目录</h3>
<ol>
  <li>介绍</li>
  <li>用途</li>
  <li>Runloop Mode</li>
  <li>Runloop Mode Item</li>
  <li>Run Loop 运行机制</li>
  <li>自定义 input source</li>
</ol>

<h3 id="section-1">介绍</h3>

<p>Run Loop 正如其字面意思一样，表示运行循环，可以理解为一个 do-while 循环。Run Loop 与线程密切相关，每个线程对应着自己的一个 Run Loop，但是除了主线程的 Run Loop 是默认开启之外，剩下的线程的 Run Loop 一开始是不存在的，需要手动通过 <code>[NSRunLoop currentRunLoop]</code> 或 <code>CFRunLoopGetCurrent()</code> 获取当前线程的 Run Loop，这两个方法分别对应着 Foundation 框架和 Core Foundation 框架，它们的原理为，若当前线程对应的 Run Loop 存在的时候，直接返回该 Run Loop，当该线程当前不存在 Run Loop 时候，就创建当前线程的 Run Loop。 Foundation 框架的方法是对 Core Foundation 框架的方法做了一层封装，另外，NSRunloop 是非线程安全的，而 CFRunloopRef 是线程安全的。</p>

<h3 id="section-2">用途</h3>

<p>Run Loop 主要是用来保持线程常驻，从而接收事件的。比如常见的触摸事件，就是通过主线程的 Run Loop 来接收，然后再分发给相关的处理程序。</p>

<h3 id="runloop-mode">Runloop Mode</h3>

<p>每一个 Run Loop 包含着多个 Runloop mode，每次运行的时候，它只会运行在一个特定的 Runloop mode 下，iOS 系统常用的 Runloop Mode 有两个：</p>

<ul>
  <li>kCFRunLoopDefaultMode (NSDefaultRunLoopMode)</li>
  <li>UITrackingRunLoopMode。</li>
</ul>

<p>另外还有一种特殊的commonModes：kCFRunLoopCommonModes(NSRunLoopCommonModes)， 这种情况可以理解为别的 Mode 的集合，假如一个 Run Loop 运行在 UITrackingRunLoopMode 下，那么它不但会接收被标记为 UITrackingRunLoopMode 的事件， 也会接收被标记为 NSRunLoopCommonModes 的事件。我们可能会遇到这种情况，当一个 UIScrollView 在滑动的时候，主线程的 NSTimer 事件就不触发了，这种情况是因为当 UIScrollView 在滑动的时候，主线程的 Run Loop 就处于 UITrackingRunLoopMode 下，只接收被标记为 UITrackingRunLoopMode 和 NSRunLoopCommonModes 的事件， 而 NSTimer 默认被标记为 NSDefaultRunLoopMode 的，所以该 timer 事件就被丢弃了。解决的办法是通过</p>

<p><code>- (void)addTimer:(NSTimer *)timer forMode:(NSString *)mode</code></p>

<p>来让此 timer 被标记为 NSRunLoopCommonModes 或 UITrackingRunLoopMode， 最好是被标记为 NSRunLoopCommonModes，这样，不管线程的 Run Loop 运行在什么 Mode 下，都能接收到事件了。</p>

<h3 id="runloop-mode-item">Runloop Mode Item</h3>

<p>每一个 Runloop Mode 都包含若干 Mode Item，Mode Item 有3种，分别是 Source， Timer 和 Observer。每一个Run Loop 会运行在特定的 Mode 下，这个 Mode 里面必须包含至少一个 Mode Item，如果这个 Mode 里面没有包含任何 Mode Item，那么当前的 Run Loop 会立刻退出。我们可以通过以下方法来添加 Mode Item 到指定的 Mode 中：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CFRunLoopAddSource</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopSourceRef</span> <span class="n">source</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">);</span>
</span><span class="line"><span class="n">CFRunLoopAddObserver</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">);</span>
</span><span class="line"><span class="n">CFRunLoopAddTimer</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopTimerRef</span> <span class="n">timer</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>通过下面的方法把 Mode Item 从指定 Mode 中移除</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CFRunLoopRemoveSource</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopSourceRef</span> <span class="n">source</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">);</span>
</span><span class="line"><span class="n">CFRunLoopRemoveObserver</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">);</span>
</span><span class="line"><span class="n">CFRunLoopRemoveTimer</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopTimerRef</span> <span class="n">timer</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<h4 id="source">Source</h4>

<p>Source（CFRunLoopSourceRef） 用来产生事件的，它有两个版本 Source0 和 Source1。</p>

<p>Source0 包含了一个回调函数，它无法主动唤醒线程的 Run Loop，需要先使用CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p>

<p>Source1 被称为基于 Port 的 source （Port based source）; 它主要用来进行线程间的通信，能主动唤醒线程的 Run Loop。</p>

<h4 id="timer">Timer</h4>

<p>Timer 就是我们平时使用的 NSTimer，它实际上是对 CFRunLoopTimerRef 进行了封装，当我们将其加入 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行对应的回调函数。</p>

<p>假如 Timer 被设置为只触发一次，其触发后会从Run Loop中移除，假如 Timer 被设置为循环触发时，会一直保存在当前Run Loop中，直到调用invalidated方法。</p>

<h4 id="observer">Observer</h4>

<p>Run Loop 的 Observer(CFRunLoopObserverRef) 会观察 Run Loop 的运行状态，对于不同的状态执行不同的回调函数，Run Loop 的状态有以下几种:</p>

<ul>
  <li>Run Loop 进入的时候</li>
  <li>Run Loop 即将处理一个Timer的时候</li>
  <li>Run Loop 即将处理一个Input Source的时候</li>
  <li>Run Loop 即将进入休眠的时候</li>
  <li>Run Loop 刚从休眠中被被唤醒的时候</li>
  <li>Run Loop 即将退出的时候</li>
</ul>

<p>Observer 同 Timer 类似，在被设置为只触发一次，其触发后会从Run Loop中移除，假如被设置为循环触发时，会一直保存在当前Run Loop中。</p>

<h3 id="run-loop-">Run Loop 运行机制</h3>

<p>Run Loop 是用来接收事件的一个循环，其生命周期如下：</p>

<ol>
  <li>通知观察者 Run Loop已经启动</li>
  <li>通知观察者 Timer即将被触发</li>
  <li>通知观察者即将触发 Source0 事件</li>
  <li>启动 Source0 事件</li>
  <li>如果 Source1 准备好并处于等待状态，立即处理，并进入步骤9。</li>
  <li>通知观察者线程进入休眠</li>
  <li>将线程置于休眠直到任一下面的事件发生：
    <ul>
      <li>某一事件到达基于 Port 的 Source</li>
      <li>定时器启动</li>
      <li>Run Loop设置的时间已经超时</li>
      <li>Run Loop被显式唤醒</li>
    </ul>
  </li>
  <li>通知观察者线程将被唤醒。</li>
  <li>处理未处理的事件:
    <ul>
      <li>如果用户定义的定时器启动，处理定时器事,进入步骤2</li>
      <li>如果 Source1 启动，传递相应的消息</li>
      <li>如果 Run Loop 被显式唤醒而且时间还没超时,进入步骤2</li>
    </ul>
  </li>
  <li>通知观察者 Run Loop 结束。</li>
</ol>

<p>上述步骤中，2-9 处于一个 while 循环中。</p>

<h3 id="input-source">自定义 input source</h3>

<h4 id="source0">Source0</h4>

<p>我们首先定义一个 Source：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CFRunLoopSourceContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,(</span><span class="k">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="nb">self</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">runLoopSourceFired</span><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="nb">self</span><span class="p">.</span><span class="n">inputSource</span> <span class="o">=</span> <span class="n">CFRunLoopSourceCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>其中 context 里面的最后一个参数表示 source 触发时候的回调函数:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">void</span> <span class="nf">runLoopSourceFired</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;source0 Fired&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>之后我们建立并开启一个线程：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="nb">self</span><span class="p">.</span><span class="kr">thread</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">p_threadWillEnter</span><span class="p">)</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="kr">thread</span> <span class="n">start</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<p>在这个线程里我们执行如下方法：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">p_threadWillEnter</span><span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">        <span class="n">CFRunLoopRef</span> <span class="n">currentRunloop</span> <span class="o">=</span> <span class="n">CFRunLoopGetCurrent</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">        <span class="nb">self</span><span class="p">.</span><span class="n">backgroundRunloop</span> <span class="o">=</span> <span class="n">currentRunloop</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="n">CFRunLoopAddSource</span><span class="p">(</span><span class="n">currentRunloop</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">inputSource</span><span class="p">,</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">);</span><span class="c1">//添加 source0 到当前线程的 Run Loop 里</span>
</span><span class="line">
</span><span class="line">        <span class="k">do</span> <span class="p">{</span>
</span><span class="line">            <span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">runMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span> <span class="nl">beforeDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">distantFuture</span><span class="p">]];</span><span class="c1">//开启 Run Loop</span>
</span><span class="line">        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">YES</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>之后假如有事件发生，我们需要通知辅助线程，执行 source0 回调:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">buttonDidClicked:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="n">CFRunLoopSourceSignal</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">inputSource</span><span class="p">);</span> <span class="c1">//将该 source 标记为待处理</span>
</span><span class="line">
</span><span class="line">    <span class="n">CFRunLoopWakeUp</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">backgroundRunloop</span><span class="p">);</span> <span class="c1">//唤醒辅助线程</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>这样，每按一下按钮，我们就会看到后台线程被唤醒，并执行了 source0 的回调，打印出了 “source0 Fired”。</p>

<h4 id="source1-port-based-source">Source1 (Port-based Source)</h4>

<p>首先定义一个 NSPort</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line">  <span class="nb">self</span><span class="p">.</span><span class="n">mainThreadPort</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSPort</span> <span class="n">port</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<p>之后设置处理该 port 接收事件的 delegate</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line">   <span class="nb">self</span><span class="p">.</span><span class="n">mainThreadPort</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>把该 port 加入到 Run Loop 里,并开启 Run Loop</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addPort</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">mainThreadPort</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class="line"><span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="n">run</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<p>实现 port 的 delegate 方法：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handlePortMessage:</span><span class="p">(</span><span class="n">NSPortMessage</span> <span class="o">*</span><span class="p">)</span><span class="nv">message</span><span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="kt">UInt32</span> <span class="n">msid</span> <span class="o">=</span> <span class="p">[</span><span class="n">message</span> <span class="n">msgid</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;msid == %d&quot;</span><span class="p">,</span><span class="n">msid</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>创建新的线程和该线程的 Port</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="nb">self</span><span class="p">.</span><span class="n">backgroundThread</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">p_threadWillEnter</span><span class="p">)</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line"><span class="nb">self</span><span class="p">.</span><span class="n">backgroundThreadPort</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSPort</span> <span class="n">port</span><span class="p">];</span>
</span><span class="line"><span class="nb">self</span><span class="p">.</span><span class="n">backgroundThreadPort</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>开启该线程的 Run Loop</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">p_threadWillEnter</span><span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">        <span class="bp">NSRunLoop</span> <span class="o">*</span><span class="n">runloop</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">        <span class="p">[</span><span class="n">runloop</span> <span class="nl">addPort</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">backgroundThreadPort</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">        <span class="k">do</span><span class="p">{</span>
</span><span class="line">            <span class="p">[</span><span class="n">runloop</span> <span class="nl">runMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span>
</span><span class="line">                  <span class="nl">beforeDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">distantFuture</span><span class="p">]];</span>
</span><span class="line">        <span class="p">}</span><span class="k">while</span> <span class="p">(</span><span class="nb">YES</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>从 backgroundThread 向 mainThread 发送信息</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">buttonClicked:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSPortMessage</span><span class="o">*</span> <span class="n">messageObj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSPortMessage</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSendPort</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">mainThreadPort</span>
</span><span class="line">                                                            <span class="nl">receivePort</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">backgroundThreadPort</span> <span class="nl">components</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">messageObj</span><span class="p">){</span>
</span><span class="line">        <span class="p">[</span><span class="n">messageObj</span> <span class="nl">setMsgid</span><span class="p">:</span><span class="mi">150</span><span class="p">];</span>
</span><span class="line">        <span class="p">[</span><span class="n">messageObj</span> <span class="nl">sendBeforeDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">]];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>这样每次按按钮，就会看到 <code>- (void)handlePortMessage:(NSPortMessage *)message</code> 回调方法被执行了，实现了线程间基于 Port 的通信。注意这个代码时运行在 OS X 上的，因为 iOS 里面 没有 <code>NSPortMessage</code>。</p>

<h3 id="section-3">参考资料</h3>

<ol>
  <li>
    <p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">Run Loops</a></p>
  </li>
  <li>
    <p><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解 RunLoop</a></p>
  </li>
  <li>
    <p><a href="http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-%5B%3F%5D-:shi-yao-shi-run-loop%3F/">走进Run Loop的世界 (一)</a></p>
  </li>
  <li>
    <p><a href="http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-er-:ru-he-pei-zhi-run-loop-sources/">走进Run Loop的世界 (二)</a></p>
  </li>
  <li>
    <p><a href="http://www.dreamingwish.com/article/ios-multithread-program-runloop-the.html">iOS多线程编程指南（三）Run Loop</a></p>
  </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 中线程同步的一些方法]]></title>
    <link href="http://alex1212112.github.io/blog/2015/10/23/ios-zhong-xian-cheng-tong-bu-de-%5B%3F%5D-xie-fang-fa/"/>
    <updated>2015-10-23T15:21:04+08:00</updated>
    <id>http://alex1212112.github.io/blog/2015/10/23/ios-zhong-xian-cheng-tong-bu-de-[?]-xie-fang-fa</id>
    <content type="html"><![CDATA[<h3 id="section">目录</h3>
<ol>
  <li>使用串行队列</li>
  <li>使用 dispatch_group</li>
  <li>使用 dispatch_barrier</li>
  <li>使用 dispatch_semaphore</li>
</ol>

<h3 id="section-1">串行队列</h3>
<p>使用串行队列，对于一个资源，同一时刻只有一个任务（线程）访问，这样就避免了资源竞争，实现了资源的同步。我们可以通过 NSOperationQueue 或 dispatch queue来实现串行队列。</p>

<ul>
  <li>
    <p>NSOperationQueue</p>

    <p>创建一个	NSOperationQueue 队列，然后将该队列的最大并发数设置为 1，就是一个串行队列。</p>
  </li>
</ul>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSOperationQueue</span> <span class="o">*</span> <span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">queue</span><span class="p">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//每次只执行一个任务</span>
</span><span class="line">
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="bp">NSInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">count</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">
</span><span class="line">        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span> <span class="p">]];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<ul>
  <li>dispatch queue
dispatch queue 也分串行队列和并发队列，我们这里需要创建一个串行队列。</li>
</ul>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">dispatch_queue_t</span> <span class="n">serialQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.ghren.MultiThread.test&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span> <span class="c1">//生成一个串行队列</span>
</span><span class="line">
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="bp">NSInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">count</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">
</span><span class="line">        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
</span><span class="line">    <span class="p">});</span><span class="c1">//向该串行队列中添加任务</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="dispatchgroup">使用 dispatch_group</h3>

<p>dispatch_group 可以把很多个任务加入到一个组中，然后等组中所有的任务都执行完毕，再去执行新的任务，同步的操作就在这新的任务中实现。</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line">  <span class="kt">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">    <span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="bp">NSInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">count</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">        <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">
</span><span class="line">            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
</span><span class="line">        <span class="p">});</span><span class="c1">//把任务添加到组中</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">dispatch_group_wait</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span><span class="c1">//阻塞当前线程，一直到组中任务完成</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;done&quot;</span><span class="p">);</span> <span class="c1">//数据同步点</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="dispatchbarrier">使用 dispatch_barrier</h3>

<p>假如有这样一个情况，先要执行一组并发的任务，然后在执行一个基于这组并发任务的任务，然后再执行另外一组基于这个任务的并发任务，这种情况虽然也可以通过 dispatch_group 来实现， 但是 GCD 提供了另外一个很优雅的方法，就是 dispatch_barrier,要注意的是对于串行队列使用 dispatch_barrier 意义并不大，因为所有的任务本来就是串行执行的，对于全局的并发队列 <code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code> , dispatch_barrier 也不会生效，所以 dispatch_barrier 一般使用在 自定义的全局并发队列里</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="kt">dispatch_queue_t</span> <span class="n">concurrentQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;com.ghren.MultiThread.concurrent&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span> <span class="c1">//生成一个并发队列, dispatch_barrier 对于全局并发队列并不起作用，所以要用在自己创建的并发队列里</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="bp">NSInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">count</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">
</span><span class="line">            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
</span><span class="line">        <span class="p">});</span>
</span><span class="line">    <span class="p">}</span> <span class="c1">// 向并发队列里添加任务</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">    <span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">
</span><span class="line">        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;do something&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="p">});</span><span class="c1">//同步点</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="bp">NSInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">count</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">concurrentQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">
</span><span class="line">            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span><span class="n">count</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
</span><span class="line">        <span class="p">});</span>
</span><span class="line">    <span class="p">}</span><span class="c1">//向并发队列里添加新的任务</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="dispatchsemaphore">使用 dispatch_semaphore</h3>

<p>dispatch_semaphore 就是传说中的信号量。其基本原理是，我们可以创建一个信号量，这个信号量有一个值，来表示目前信号量总数有多少，比如我们可以创建一个初始值为 2 的信号量，然后当我们执行一个任务的时候，就消耗一个信号量，信号量总数会减 1 ，当信号量为 0 的时候，即将执行的任务将会被阻塞，然后一直等到超时或信号量又大于0 为止，当我们在一个任务执行完毕的时候，可以为信号量的总量加 1 ，当信号量从 0 变成 1 的时候，等待信号量的任务就会执行下去，通过这个机制，我们可以实现数据的同步。</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">dispatch_semaphore_t</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="n">dispatch_semaphore_create</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="kt">dispatch_time_t</span> <span class="n">time</span> <span class="o">=</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span><span class="n">NSEC_PER_SEC</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;task will begin&quot;</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="n">dispatch_after</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;task is done&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="p">});</span><span class="c1">//3 秒之后在全局并发队列里添加一个任务，任务执行完毕之后，增加一个信号量</span>
</span><span class="line">
</span><span class="line"><span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span><span class="c1">//当前线程处于阻塞状态，直到信号量不为0</span>
</span><span class="line">
</span><span class="line"><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;start another task&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa 学习资料]]></title>
    <link href="http://alex1212112.github.io/blog/2015/08/19/reactivecocoa-xue-xi-zi-liao/"/>
    <updated>2015-08-19T17:58:36+08:00</updated>
    <id>http://alex1212112.github.io/blog/2015/08/19/reactivecocoa-xue-xi-zi-liao</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201508191805.png" alt="" /></p>

<ol>
  <li>
    <p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">官方地址（github）</a></p>
  </li>
  <li><a href="http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html">ReactiveCocoa与Functional Reactive Programming</a></li>
  <li>
    <p><a href="http://limboy.me/ios/2013/12/27/reactivecocoa-2.html">说说ReactiveCocoa 2</a></p>
  </li>
  <li><a href="http://limboy.me/ios/2014/06/06/deep-into-reactivecocoa2.html">ReactiveCocoa2实战</a></li>
  <li>
    <p><a href="http://nshipster.cn/reactivecocoa/">Reactive​Cocoa-NSHipster</a></p>
  </li>
  <li><a href="http://yulingtianxia.com/blog/2014/07/29/reactivecocoa/">ReactiveCocoa学习笔记</a></li>
  <li>
    <p><a href="http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part1">ReactiveCocoa入门教程——第一部分</a></p>
  </li>
  <li><a href="http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part2">ReactiveCocoa入门教程——第二部分</a></li>
  <li>
    <p><a href="http://southpeak.github.io/blog/2014/09/21/zai-reactivecocoazhong-jiang-%5B%3F%5D-ge-viewmodelbang-ding-dao-uitableviewshang/">在ReactiveCocoa中将一个ViewModel绑定到UITableView上</a></p>
  </li>
  <li>
    <p><a href="http://blog.devtang.com/blog/2014/02/11/reactivecocoa-introduction/">ReactiveCocoa - iOS开发的新框架</a></p>
  </li>
  <li><a href="http://blog.sunnyxx.com/2014/03/06/rac_0_overview/">Reactive Cocoa Tutorial [0] = Overview</a></li>
  <li>
    <p><a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/">Reactive Cocoa Tutorial [1] = 神奇的Macros</a></p>
  </li>
  <li><a href="http://blog.sunnyxx.com/2014/03/06/rac_2_racstream/">Reactive Cocoa Tutorial [2] = 百变RACStream</a>;</li>
  <li>
    <p><a href="http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/">Reactive Cocoa Tutorial [3] = RACSignal的巧克力工厂</a></p>
  </li>
  <li><a href="http://blog.sunnyxx.com/2014/04/19/rac_4_filters/">Reactive Cocoa Tutorial [4] = 只取所需的Filters</a></li>
</ol>

<p>学习顺序为 2，3，4，7，8，11，12，13，14，15，其他。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于 UILocalNotification 的几个问题]]></title>
    <link href="http://alex1212112.github.io/blog/2015/05/27/guan-yu-uilocalnotification-de-ji-ge-wen-ti/"/>
    <updated>2015-05-27T18:47:25+08:00</updated>
    <id>http://alex1212112.github.io/blog/2015/05/27/guan-yu-uilocalnotification-de-ji-ge-wen-ti</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201505271852.png" alt="" /></p>

<h3 id="section">问题</h3>

<ol>
  <li>
    <p>如何修改已经启动的<code>UILocalNotification</code></p>
  </li>
  <li>
    <p>为何<code>cancelAllLocalNotifications</code>方法调用完毕之后并不生效</p>
  </li>
</ol>

<h3 id="section-1">回答</h3>

<ol>
  <li>
    <p>停止已经启动的<code>UILocalNotification</code>，创建一个新的<code>UILocalNotification</code>并启动，直接修改已经启动的<code>UILocalNotification</code>是不生效的，因为你在<code>[[UIApplication sharedApplication] scheduleLocalNotification:notification]</code>的时候，复制了一个当前的notification，并提交到系统的推送队列上，假如不提交的话，系统是不认识这个notification的。</p>
  </li>
  <li>
    <p>执行完 <code>cancelAllLocalNotifications</code> 后，你再打印<code>[UIApplication sharedApplication].scheduledLocalNotifications</code>,发现其并不为空,stackoverflow 上有人说这个方法不是同步执行的，只会在当前的 run loop 结束之后生效,有人说可以通过</p>
  </li>
</ol>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="bp">UIApplication</span> <span class="n">sharedApplication</span><span class="p">].</span><span class="n">scheduledLocalNotifications</span> <span class="o">=</span> <span class="nb">nil</span>
</span></code></pre></td></tr></table></div></figure>

<p>的方法使其立即生效，测试发现并没有什么作用，真正有用的方法还是 stackoverflow 上一个开发者提出的变通方法:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[[</span><span class="bp">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="n">cancelAllLocalNotifications</span><span class="p">];</span>
</span><span class="line">    <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span> <span class="p">((</span><span class="n">count</span> <span class="o">=</span> <span class="p">[[[</span><span class="bp">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="n">scheduledLocalNotifications</span><span class="p">]</span> <span class="n">count</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Remaining notificaitons to cancel: %lu&quot;</span><span class="p">,(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">count</span><span class="p">);</span>
</span><span class="line">        <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">.01f</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>对于问题1，有时候在 ` [[UIApplication sharedApplication] cancelLocalNotification:notification]<code>的时候可能会发现并没有立即cancel掉，也可以采用这样的方法，在 cancel 完之后 执行下 </code>[NSThread sleepForTimeInterval:.01f]`;</p>

<h3 id="section-2">参考资料</h3>

<ol>
  <li>
    <p><a href="http://stackoverflow.com/questions/25948037/ios-8-uiapplication-sharedapplication-scheduledlocalnotifications-empty">scheduledLocalNotifications</a></p>
  </li>
  <li>
    <p><a href="http://stackoverflow.com/questions/13163535/cancelalllocalnotifications-not-working-on-iphone-3gs">cancelAllLocalNotifications</a></p>
  </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8 中的实时模糊 View－UIVisualEffectView]]></title>
    <link href="http://alex1212112.github.io/blog/2015/05/10/ios8-zhong-de-shi-shi-mo-hu-view%5Bnil%5Duivisualeffectview/"/>
    <updated>2015-05-10T13:08:00+08:00</updated>
    <id>http://alex1212112.github.io/blog/2015/05/10/ios8-zhong-de-shi-shi-mo-hu-view[nil]uivisualeffectview</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201505101313.png" alt="" /></p>

<h3 id="section">介绍</h3>

<p>在iOS7 以后，整个扁平化的 iOS 界面都大量采用了高斯模糊的效果来展示层次，比如在主界面上从底面上划出来 的控制面板，或者从顶部向下划出来的通知栏界面，都实时模糊了主界面背景，在 iOS7 的时候我们总共有 3.5 个办法来实现这些效果：</p>

<ol>
  <li>利用苹果开源的 UIImage+ImageEffects</li>
  <li>利用 GPUImage 的高斯模糊滤镜</li>
  <li>利用CoreImage 的高斯模糊滤镜</li>
</ol>

<p>在 iOS7 初期的时候还有人使用 UIToolBar 覆盖在 superView 上的方法来实现，但是后来这个方法失效了，所以只能算半个。不过到了 iOS8，苹果提供了一个非常好用的方案－UIVisualEffectView。</p>

<p>UIVisualEffectView 是 UIView 的子类，因此使用的时候就是实例化一个 UIVisualEffectView，然后添加到superView 上就 OK 了。 That‘s it，就这么简单。</p>

<p>UIVisualEffectView 有两种效果，一种是 UIBlurEffect，即高斯模糊效果，一种是 UIVibrancyEffect，这种效果能把背景 View 和 当前 View 混合起来，通常使用的时候要在模糊后的 View 上 显示一些内容的话，就要在 UIBlurEffect 的 View 上 再添加一层 UIVibrancyEffect，这样可以使整个显示效果更舒适一点，下面这张图展示了在背景图片完全相同的情况下使用和不使用 Vibrancy 的不同:</p>

<p><img src="http://alex1212112.github.io/images/10310Q192-19.png" alt="" /></p>

<h3 id="section-1">代码</h3>

<p>Objectivie-C</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="c1">//初始化一个 UIVisualEffect，UIBlurEffect 是 UIVisualEffect 的子类</span>
</span><span class="line"><span class="n">UIBlurEffect</span> <span class="o">*</span><span class="n">blurEffect</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBlurEffect</span> <span class="nl">effectWithStyle</span><span class="p">:</span><span class="n">UIBlurEffectStyleExtraLight</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="c1">//初始化 模糊效果的 UIVisualEffectView</span>
</span><span class="line"><span class="n">UIVisualEffectView</span> <span class="o">*</span> <span class="n">blurEffectView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIVisualEffectView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithEffect</span><span class="p">:</span><span class="n">blurEffect</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="c1">//设置 blurEffectView 的 frame</span>
</span><span class="line"><span class="n">blurEffectView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//添加 blurEffectView 到 self.View 上,如果只是做模糊效果，那么到这一步已经完了</span>
</span><span class="line"><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">blurEffectView</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="c1">//初始化 Vibrancy 类型的 UIVisualEffect，vibrancyEffect 也是UIVisualEffect 的子类，而且初始化这个 Effect 需要用到 blurEffect，我们就还用上面的好了，假如重新初始化一个 blurEffect，要注意这个新的 blurEffect 的 style 要和上面的保持一致，不然就实现不了 Vibrancy效果</span>
</span><span class="line"><span class="n">UIVibrancyEffect</span> <span class="o">*</span><span class="n">vibrancyEffect</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIVibrancyEffect</span> <span class="nl">effectForBlurEffect</span><span class="p">:</span><span class="n">blurEffect</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="c1">//初始化 Vibrancy 效果的 UIVisualEffectView</span>
</span><span class="line"><span class="n">UIVisualEffectView</span> <span class="o">*</span><span class="n">vibrancyEffectView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIVisualEffectView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithEffect</span><span class="p">:</span><span class="n">vibrancyEffect</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="c1">//设置 vibrancyEffectView 的frame</span>
</span><span class="line"><span class="n">vibrancyEffectView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">blurEffectView</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="c1">//注意是 blurEffectView.contentView. 苹果官方注释说了  Do not add subviews directly to UIVisualEffectView, use this view instead</span>
</span><span class="line"><span class="p">[</span><span class="n">blurEffectView</span><span class="p">.</span><span class="n">contentView</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">vibrancyEffectView</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="c1">//初始化一个 label</span>
</span><span class="line"><span class="bp">UILabel</span> <span class="o">*</span><span class="n">label</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UILabel</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">vibrancyEffectView</span><span class="p">.</span><span class="n">bounds</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">label</span><span class="p">.</span><span class="n">textAlignment</span> <span class="o">=</span> <span class="n">NSTextAlignmentCenter</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">@&quot;Live long and Prosper&quot;</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">label</span><span class="p">.</span><span class="n">font</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIFont</span> <span class="nl">fontWithName</span><span class="p">:</span><span class="s">@&quot;SnellRoundhand-Black&quot;</span> <span class="nl">size</span><span class="p">:</span><span class="mf">29.0f</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="c1">//添加 label</span>
</span><span class="line"><span class="p">[</span><span class="n">vibrancyEffectView</span><span class="p">.</span><span class="n">contentView</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">label</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-2">参考资料</h3>

<ol>
  <li><a href="http://www.raywenderlich.com/84043/ios-8-visual-effects-tutorial">UIVisualEffectView Tutorial</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 与 Objective-C 混编及如何调用 Cocoapods]]></title>
    <link href="http://alex1212112.github.io/blog/2015/04/12/swift-yu-objective-c-hun-bian-ji-ru-he-diao-yong-cocoapods/"/>
    <updated>2015-04-12T11:42:05+08:00</updated>
    <id>http://alex1212112.github.io/blog/2015/04/12/swift-yu-objective-c-hun-bian-ji-ru-he-diao-yong-cocoapods</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201504121200.png" alt="" /></p>

<h3 id="section">目录</h3>

<ol>
  <li>Swift 与 Objectve-C 混编</li>
  <li>Swift 如何使用 Objective-C 的 cocoapods</li>
</ol>

<h3 id="swift--objectve-c-">Swift 与 Objectve-C 混编</h3>

<h4 id="swift--objective-c-">Swift 文件里使用 Objective-C 类</h4>

<p>无论是在 Swift 工程中新建 Objectve-C 的类，还是在 Objective-C 中新建 Swift 的类，Xcode 都会提示 <code>Would you like to configure an Objective-C bridging header?</code> ，选择是，就会新建一个Bridging 的文件，文件的名称一般是 <code>ProjectName-Bridging-Header.h</code>,比如项目名称是 <code>Cat</code>，那么名称就会是<code>Cat-Bridging-Header.h</code>，然后在这个文件里引用 Swift 需要用到的 Objective-C 的头文件，比如</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &quot;GHCatView.h&quot;</span>
</span></code></pre></td></tr></table></div></figure>
<p>那么就在 Swift 的类里使用 Objective-C 类了.</p>

<h4 id="objective-c--swift-">Objective-C 文件里使用 Swift 类</h4>

<p>直接在.m 文件里</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &quot;Cat-swift.h&quot;</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="swift--objective-c--cocoapods">Swift 如何使用 Objective-C 的 Cocoapods</h3>

<p>通过 cocoapods 使用第三方的 Objective-C 的组件的时候，在<code>ProjectName-Bridging-Header.h</code>里面引入相关的头文件，比如你要使用 Mantle，就可以</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &lt;Mantle/Mantle.h&gt;</span>
</span></code></pre></td></tr></table></div></figure>

<p>接下来就可以在 Swift 的文件里使用了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CALayer (一)]]></title>
    <link href="http://alex1212112.github.io/blog/2015/04/07/calayer-%5B%3F%5D/"/>
    <updated>2015-04-07T11:38:10+08:00</updated>
    <id>http://alex1212112.github.io/blog/2015/04/07/calayer-[?]</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201504071154.png" alt="" /></p>

<h3 id="section">目录</h3>

<ol>
  <li>简介</li>
  <li>contents</li>
  <li>参考资料</li>
</ol>

<h3 id="section-1">简介</h3>

<p>CALayer（图层） 可以看作是UIView的内部实现，每一个 UIView 都有一个 名称为layer 的属性，我们看到的view的具体内容都是这个layer展示的，UIView 对 CALayer 做了一些封装，并在此基础之上提供了和用户交互的一系列方法。和 UIVIew 一样，CALayer 也有相同的层级关系，每一个CALyer 对象都可以增加 sublayer。通过 CALayer 我们可以实现一些 UIView 无法实现的效果，比如阴影，圆角，边框等，而且还可以实现很多 UIView 无法实现的非常炫酷的动画。</p>

<h3 id="contents">contents</h3>

<p>CALayer 有一个 id 类型的contents的属性，这个 contents 负责显示具体的内容，比如一张图片等，这里要注意假如要为 contents 设置一张图片的话，不能用UIImage，用UIImage的话，显示出来的图层上面什么都没有。要用 CGImageRef 类型的值，但 CGImageRef 不是Cocoa 对象，而是一个Core Foundation类型，所以要通过 toll-free bridging 来转换一下，比如</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">layer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge</span> <span class="kt">id</span><span class="p">)</span><span class="n">image</span><span class="p">.</span><span class="bp">CGImage</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>
<p>除了给 contents 赋值 CGImageRef 外，还可以用 Core Graphics 直接绘制的方法来设置 contents 的内容，主要是通过集成 UIView 并实现 <code>-drawRect:</code>方法来实现的。</p>

<p>关于 contents 显示的具体方式，CALayer 有一些很有用的属性可以设置，比如：</p>

<ul>
  <li>contentsGravity</li>
  <li>contentsScale</li>
  <li>maskToBounds</li>
  <li>contentsRect</li>
  <li>contentsCenter</li>
</ul>

<h4 id="contentsgravity">contentsGravity</h4>

<p>contentsGravity 类似于 UIView 中的 contentMode 属性，就是决定 contents 在图层的边界中怎么对齐，比如是居中还是靠上等，contentsGravity可选的常量值主要有：</p>

<ul>
  <li>kCAGravityCenter</li>
  <li>kCAGravityTop</li>
  <li>kCAGravityBottom</li>
  <li>kCAGravityLeft</li>
  <li>kCAGravityRight</li>
  <li>kCAGravityTopLeft</li>
  <li>kCAGravityTopRight</li>
  <li>kCAGravityBottomLeft</li>
  <li>kCAGravityBottomRight</li>
  <li>kCAGravityResize</li>
  <li>kCAGravityResizeAspect</li>
  <li>kCAGravityResizeAspectFill</li>
</ul>

<p>我们可以从名字看出它们的作用。</p>

<h4 id="contentsscale">contentsScale</h4>

<p>contentsScale 主要用来告诉系统在绘制 contents 的时候一个点绘制几个像素，比如以前的非 Retina 屏幕的时候，就是1，现在的 Phone6 plus 是3，别的 Retina 屏幕就是2，因此当我们是 Retina 屏幕的时候在设置 图层的 contents 的时候不要忘了加上</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">layer</span><span class="p">.</span><span class="n">contentsScale</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIScreen</span> <span class="n">mainScreen</span><span class="p">]</span> <span class="n">scale</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>####maskToBounds</p>

<p>作用和 UIView 的 clipsToBounds 类似，就是决定是否显示超出该图层边界的内容，要注意如果该属性要设置为 YES 的话，再设置阴影效果是不起作用的，因为阴影超出了图层的边界。</p>

<h4 id="contentsrect">contentsRect</h4>

<p>contentsRect 能让 CALayer 只显示 contents 的一部分，它的范围在 0 到 1 之间,比如说设置如下：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">layer</span><span class="p">.</span><span class="n">contentsRect</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>那么实际显示在layer上的就是 contents 的左上部分。这个方法在一些地方会很有用，比如 cocosd 中精灵纹理的图片就是载入一张拼合了很多图片的大图，然后在需要的时候通过这个方法对不同的区域进行切割。</p>

<h4 id="contentscenter">contentsCenter</h4>

<p>contentsCenter是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域，它的范围在 0 到 1 之间，只有 contents 大小和图层大小不一致时，才发挥作用，系统默认的 contentsCenter 的大小为 {0,0,1,1}, 即 contents 会被均匀的拉伸，如果我们设置:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">layer</span><span class="p">.</span><span class="n">contentsCenter</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>那么其均匀拉伸的区域就是中间的区域，四个角的地方保持不变，借用一张图表示如下:</p>

<p><img src="http://alex1212112.github.io/images/contentsCenter.png" alt="" /></p>

<h3 id="section-2">参考资料</h3>
<ol>
  <li>
    <p><a href="http://zsisme.gitbooks.io/ios-/content/chapter2/the-contents-image.html">contents 属性</a></p>
  </li>
  <li>
    <p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CALayer_class/index.html">CALayer</a></p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CIKernel 的学习]]></title>
    <link href="http://alex1212112.github.io/blog/2015/03/23/cikernel-de-xue-xi/"/>
    <updated>2015-03-23T21:39:36+08:00</updated>
    <id>http://alex1212112.github.io/blog/2015/03/23/cikernel-de-xue-xi</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201503232142.png" alt="" /></p>

<p>在使用 Core Image 的时候，Apple 提供的效果有时候无法满足我们的需求，我们希望能实现自己的滤镜，这个时候我们可以用 CIKernel。CIKernel 是 iOS8 的时候出现的，它是一种类似于 OpenGL 着色器的处理程序。苹果提供了一系列的函数和数据类型供我们使用它。具体参见<a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CIKernelLangRef/ci_gslang_ext.html">Core Image Kernel Language</a>。</p>

<h3 id="section">子类</h3>

<p>CIKernel 有两个子类：<code>CIColorKernel</code>和<code>CIWarpKernel</code>。</p>

<h3 id="section-1">初始化</h3>

<p>我们通过一个 <code>NSString</code> 来初始化一个 <code>CIKernel</code>；</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line">   <span class="bp">NSString</span> <span class="o">*</span><span class="n">kernelString</span> <span class="o">=</span>
</span><span class="line">    <span class="s">@&quot;kernel vec4 moveUpTwoPixels (sampler image) {</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class="line">    <span class="s">@&quot;  vec2 dc = destCoord();</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class="line">    <span class="s">@&quot;  vec2 offset = vec2(0.0, 2.0);</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class="line">    <span class="s">@&quot;  return sample (image, samplerTransform (image, dc + offset));</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class="line">    <span class="s">@&quot;}&quot;</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">CIKernel</span> <span class="o">*</span><span class="n">kernel</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIKernel</span> <span class="nl">kernelWithString</span><span class="p">:</span><span class="n">kernelString</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-2">使用</h3>

<p>使用的时候可以这么用：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;flower&quot;</span><span class="p">];</span>
</span><span class="line"><span class="bp">CIImage</span> <span class="o">*</span><span class="n">inputImage</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIImage</span> <span class="nl">imageWithCGImage</span><span class="p">:</span><span class="n">image</span><span class="p">.</span><span class="bp">CGImage</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="bp">CIImage</span> <span class="o">*</span><span class="n">outImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">kernel</span> <span class="nl">applyWithExtent</span><span class="p">:</span><span class="n">inputImage</span><span class="p">.</span><span class="n">extent</span> <span class="nl">roiCallback</span><span class="p">:</span><span class="o">^</span><span class="bp">CGRect</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">inputImage</span><span class="p">.</span><span class="n">extent</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="p">}</span> <span class="nl">arguments</span><span class="p">:</span><span class="l">@[</span><span class="n">inputImage</span><span class="l">]</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<p>我们可以看到，核心代码为：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">kernel</span> <span class="n">vec4</span> <span class="nf">moveUpTwoPixels</span> <span class="p">(</span><span class="n">sampler</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">vec2</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">destCoord</span><span class="p">();</span>
</span><span class="line">    <span class="n">vec2</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</span><span class="line">    <span class="k">return</span> <span class="n">sample</span> <span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">samplerTransform</span> <span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">dc</span> <span class="o">+</span> <span class="n">offset</span><span class="p">));</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>这是一个 函数，其中返回值 vec4 是一个 由 float 构成的向量，苹果在文档里说这个函数的返回值必须是这种类型。函数的名称 叫 <code>moveUpTwoPixels</code>,函数的参数为一个 sampler 类型，对于我们的程序来说，这个参数要求我们传递一个CIImage，这里的参数也可以有多个，对应着</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="bp">CIImage</span> <span class="o">*</span><span class="p">)</span><span class="nf">applyWithExtent:</span><span class="p">(</span><span class="bp">CGRect</span><span class="p">)</span><span class="nv">extent</span>
</span><span class="line">                   <span class="nf">arguments:</span><span class="p">(</span><span class="bp">NSArray</span><span class="o">*</span><span class="p">)</span><span class="nv">args</span>
</span></code></pre></td></tr></table></div></figure>
<p>方法里的 args 的参数。</p>

<h3 id="cicolorkernel">CIColorKernel</h3>

<p>我们也可以创建一个CIColorKernel:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSString</span> <span class="o">*</span><span class="n">kernelString</span> <span class="o">=</span>
</span><span class="line">    <span class="s">@&quot;kernel vec4 chromaKey( __sample s, __color c, float threshold ) { </span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class="line">    <span class="s">@&quot;  vec4 diff = s.rgba - c;</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class="line">    <span class="s">@&quot;  float distance = length( diff );</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class="line">    <span class="s">@&quot;  float alpha = compare( distance - threshold, 0.0, 0.5 );</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class="line">    <span class="s">@&quot;  return vec4( s.rgb, alpha ); </span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class="line">    <span class="s">@&quot;}&quot;</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">CIColorKernel</span> <span class="o">*</span><span class="n">kernel</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIColorKernel</span> <span class="nl">kernelWithString</span><span class="p">:</span><span class="n">kernelString</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<p>使用的时候:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;flower&quot;</span><span class="p">];</span>
</span><span class="line"><span class="bp">CIImage</span> <span class="o">*</span><span class="n">inputImage</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIImage</span> <span class="nl">imageWithCGImage</span><span class="p">:</span><span class="n">image</span><span class="p">.</span><span class="bp">CGImage</span><span class="p">];</span>
</span><span class="line"><span class="bp">CIImage</span> <span class="o">*</span><span class="n">outImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">kernel</span> <span class="nl">applyWithExtent</span><span class="p">:</span><span class="n">inputImage</span><span class="p">.</span><span class="n">extent</span> <span class="nl">arguments</span><span class="p">:</span><span class="l">@[</span><span class="n">inputImage</span><span class="p">,[</span><span class="bp">CIColor</span> <span class="nl">colorWithRed</span><span class="p">:</span><span class="mf">0.0f</span> <span class="nl">green</span><span class="p">:</span><span class="mf">1.0f</span> <span class="nl">blue</span><span class="p">:</span><span class="mf">0.0f</span><span class="p">],</span><span class="mf">@0.0f</span><span class="l">]</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-3">更多</h3>

<p>进一步学习中。。。</p>

<h3 id="section-4">参考资料</h3>

<ol>
  <li>
    <p><a href="http://www.shinobicontrols.com/blog/posts/2014/08/19/ios8-day-by-day-day-19-coreimage-kernels">iOS8 Day-by-Day :: Day 19 :: CoreImage Kernels</a></p>
  </li>
  <li>
    <p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CIKernelLangRef/ci_gslang_ext.html#//apple_ref/doc/uid/TP40004397-CH206-TPXREF101">Core Image Kernel Language</a></p>
  </li>
  <li>
    <p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185">About Core Image</a></p>
  </li>
  <li>
    <p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_advanced_concepts/ci.advanced_concepts.html#//apple_ref/doc/uid/TP30001185-CH9-SW1">What You Need to Know Before Writing a Custom Filter</a></p>
  </li>
  <li>
    <p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_custom_filters/ci_custom_filters.html#//apple_ref/doc/uid/TP30001185-CH6-TPXREF101">Creating Custom Filters</a></p>
  </li>
  <li>
    <p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_image_units/ci_image_units.html#//apple_ref/doc/uid/TP30001185-CH7-SW12">Packaging and Loading Image Units</a></p>
  </li>
  <li>
    <p><a href="http://www.cocoachina.com/b/?p=174#more-174">如何制作Core Image滤镜插件</a></p>
  </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Touch ID 的使用]]></title>
    <link href="http://alex1212112.github.io/blog/2015/01/31/touch-id-de-shi-yong/"/>
    <updated>2015-01-31T19:41:53+08:00</updated>
    <id>http://alex1212112.github.io/blog/2015/01/31/touch-id-de-shi-yong</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201501312106.png" alt="" /></p>

<h3 id="section">目录</h3>

<ol>
  <li>序</li>
  <li>思路</li>
  <li>具体实现</li>
  <li>参考资料</li>
</ol>

<h3 id="section-1">序</h3>

<p>iOS8，苹果开放了 Touch ID 的 SDK，苹果自身的 Connect、 Health 应用都使用了 Touch ID 来进行解锁登录，一些第三方应用比如 1Password 也使用了Touch ID 的登录方式，那么对于我们自己的应用，如何来使用 Touch ID 这个优秀的工具呢？下面是个人的一些想法和实践。</p>

<h3 id="section-2">思路</h3>

<p>既然使用 Touch ID 来自动登录，那么一定要把用户的的账号密码信息存储起来，然后在通过 Touch ID 验证通过的时候来获取到存储的用户密码，进行登录。因为密码的安全性很重要，所以可以把密码存储到 Keychain 里，如果觉得单独的存储字符串还是不够安全，可以在存储之前做一层 AES 的加密。流程分两部分，一部分为配置Touch ID,一部分为使用 Touch ID。流程如下</p>

<h4 id="touch-id">配置 Touch ID</h4>

<ol>
  <li>用户正常登录</li>
  <li>登陆成功之后，通过 Keychain 把用户名和密码存储起来</li>
  <li>在设置里面面增加一项，启用 Touch ID，当用户选择启用 Touch ID 的时候，把该用户名存入到 NSUserDefaults 里。</li>
</ol>

<h4 id="touch-id-1">使用Touch ID</h4>

<ol>
  <li>用户输入用户名</li>
  <li>用户点击密码输入框</li>
  <li>先检查设备是否具备 Touch ID 的功能，然后通过 NSUserDefaults 查询该用户是否启用了 Touch ID 以及在 Keychain 中是否能获取到该用户信息。</li>
  <li>如果以上条件都满足，就弹出 Touch ID 验证的视图</li>
  <li>用户 通过 Touch ID 的验证，根据用户输入的用户名在 Keychain里 得到对应的密码，填充到密码框里</li>
  <li>登录</li>
</ol>

<h3 id="section-3">具体实现</h3>

<h4 id="touch-id-">检查设备是否具备 Touch ID 功能</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">canEvaluatePolicy</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">LAContext</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="p">[[</span><span class="n">LAContext</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">    <span class="kt">BOOL</span> <span class="n">success</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// test if we can evaluate the policy, this test will tell us if Touch ID is available and enrolled</span>
</span><span class="line">    <span class="n">success</span> <span class="o">=</span> <span class="p">[</span><span class="n">context</span> <span class="nl">canEvaluatePolicy</span><span class="p">:</span> <span class="n">LAPolicyDeviceOwnerAuthenticationWithBiometrics</span> <span class="nl">error</span><span class="p">:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>注意 添加 <code>@import LocalAuthentication;</code></p>

<h4 id="touch-id--ui">显示 Touch ID 的 UI视图</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">evaluatePolicyWithTitle:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">title</span> <span class="nf">successHandler:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">successHandler</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">LAContext</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="p">[[</span><span class="n">LAContext</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// show the authentication UI with our reason string</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">context</span> <span class="nl">evaluatePolicy</span><span class="p">:</span><span class="n">LAPolicyDeviceOwnerAuthenticationWithBiometrics</span> <span class="nl">localizedReason</span><span class="p">:</span><span class="n">title</span> <span class="nl">reply</span><span class="p">:</span>
</span><span class="line">     <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">success</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">authenticationError</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">         <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">
</span><span class="line">             <span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span>
</span><span class="line">             <span class="p">{</span>
</span><span class="line">                 <span class="k">if</span> <span class="p">(</span><span class="n">successHandler</span><span class="p">)</span>
</span><span class="line">                 <span class="p">{</span>
</span><span class="line">                     <span class="n">successHandler</span><span class="p">();</span>
</span><span class="line">                 <span class="p">}</span>
</span><span class="line">             <span class="p">}</span>
</span><span class="line">         <span class="p">});</span>
</span><span class="line">
</span><span class="line">     <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>其中 title 是用来描述我们使用 Touch ID来做什么的，比如 “解锁 APP” 之类的，successHandler 是 Touch ID 验证通过的回调，我们可以在这里来获取 Keychain 里的用户密码，然后进行登录，比如</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="p">[</span><span class="nb">self</span> <span class="nl">evaluatePolicyWithTitle</span><span class="p">:</span><span class="n">NSLocalizedString</span><span class="p">(</span><span class="s">@&quot;Unlock APP&quot;</span><span class="p">,</span> <span class="nb">nil</span><span class="p">)</span> <span class="nl">successHandler</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">
</span><span class="line">                    <span class="nb">self</span><span class="p">.</span><span class="n">pwdTextField</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">passwordFromKeychainWithUsername</span><span class="p">:</span><span class="n">_userNameTextField</span><span class="p">.</span><span class="n">text</span><span class="p">];</span>
</span><span class="line">                    <span class="p">[</span><span class="nb">self</span> <span class="n">login</span><span class="p">];</span>
</span><span class="line">                <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>

<h4 id="section-4">用户名密码的存储</h4>

<p>这里用的 Keychain 是 Justin Williams 封装的 SGKeychain</p>

<p>存储到 Keychain</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">saveToKeyChainWithUsername:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">username</span> <span class="nf">password:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">password</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">SGKeychainItem</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SGKeychainItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="n">item</span><span class="p">.</span><span class="n">account</span> <span class="o">=</span> <span class="n">username</span><span class="p">;</span>
</span><span class="line">    <span class="n">item</span><span class="p">.</span><span class="n">service</span> <span class="o">=</span> <span class="s">@&quot;APP&quot;</span><span class="p">;</span>
</span><span class="line">    <span class="n">item</span><span class="p">.</span><span class="n">secret</span> <span class="o">=</span> <span class="n">password</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">SGKeychain</span> <span class="nl">storeKeychainItem</span><span class="p">:</span><span class="n">item</span> <span class="nl">completionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Password successfully created&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">else</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Password failed to be created with error: %@&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">.</span><span class="n">description</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>从 Keychain 获取密码</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">passwordFromKeychainWithUsername:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">username</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">SGKeychainItem</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SGKeychainItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="n">item</span><span class="p">.</span><span class="n">account</span> <span class="o">=</span> <span class="n">username</span><span class="p">;</span>
</span><span class="line">    <span class="n">item</span><span class="p">.</span><span class="n">service</span> <span class="o">=</span> <span class="s">@&quot;APP&quot;</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// Fetch the password</span>
</span><span class="line">    <span class="p">[</span><span class="n">SGKeychain</span> <span class="nl">populatePasswordForItem</span><span class="p">:</span><span class="n">item</span> <span class="nl">completionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
</span><span class="line">
</span><span class="line">        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;error == %@&quot;</span><span class="p">,</span><span class="n">error</span><span class="p">.</span><span class="n">description</span><span class="p">);</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;password ==%@&quot;</span><span class="p">,</span><span class="n">item</span><span class="p">.</span><span class="n">secret</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">item</span><span class="p">.</span><span class="n">secret</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-5">参考资料</h3>

<ol>
  <li><a href="https://github.com/secondgear/SGKeychain">SGKeychain</a></li>
  <li><a href="http://www.cocoachina.com/ios/20141114/10222.html">在iOS 8 SDK中使用Touch ID API</a></li>
  <li><a href="http://blog.csdn.net/johnson_puning/article/details/36188255"> iOS8 Touch ID api接口调用</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C 中的方法混写(Method Swizzling)]]></title>
    <link href="http://alex1212112.github.io/blog/2014/10/20/objective-c-zhong-de-fang-fa-hun-xie-method-swizzling/"/>
    <updated>2014-10-20T17:47:07+08:00</updated>
    <id>http://alex1212112.github.io/blog/2014/10/20/objective-c-zhong-de-fang-fa-hun-xie-method-swizzling</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201410201751.png" alt="" />
###目录</p>

<ol>
  <li>什么是方法混写（Method Swizzling）</li>
  <li>如何使用方法混写</li>
  <li>注意事项</li>
  <li>参考资料</li>
</ol>

<h3 id="method-swizzling">什么是方法混写(Method Swizzling)</h3>

<p>Objective-C 中对象调用方法，或者叫“消息传递”,是通过一种动态绑定机制实现的，即对象收到消息后，究竟调用哪个方法，完全于运行期决定，而且方法名和其对应的实现也是可以在运行期改变的，这样，我们不需要源代码，也不用通过继承子类的来覆写方法，就能改变这个类中的方法。这种在运行期改变类的方法实现的手段被称之为方法混写（Method Swizzling）.</p>

<h3 id="section">如何使用方法混写</h3>

<p>举一个UIAlertView的例子，UIAlertView 有一个 show 的方法，我们想改变这个 show 的方法，可以按如下实现:</p>

<p>UIAlertView+GHSwizzling.m</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &quot;UIAlertView+GHSwizzling.h&quot;</span>
</span><span class="line"><span class="cp">#import &lt;objc/runtime.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="bp">UIAlertView</span> <span class="nl">(GHSwizzling)</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">load</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class="line">    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">
</span><span class="line">        <span class="kt">SEL</span> <span class="n">show</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="n">show</span><span class="p">);</span>
</span><span class="line">        <span class="kt">SEL</span> <span class="n">replaceSHow</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="n">_gh_show</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">        <span class="n">Method</span> <span class="n">existingMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">show</span><span class="p">);</span>
</span><span class="line">        <span class="n">Method</span> <span class="n">newMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">replaceSHow</span><span class="p">);</span>
</span><span class="line">        <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">existingMethod</span><span class="p">,</span> <span class="n">newMethod</span><span class="p">);</span><span class="c1">//交换两个方法</span>
</span><span class="line">    <span class="p">});</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">_gh_show</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="nb">self</span> <span class="n">_gh_show</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;alert show!&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>

<p>从上面代码我们可以看到，实现方法混写的步骤：</p>

<ol>
  <li>
    <p>编写自己希望实现方法的代码，上述中为 <code>_gh_show</code>,我们看到 该方法里调用了自己，好像会陷入递归调用的死循环，不过我们需要知道，这个方法是要和 <code>show</code> 方法交换的。</p>
  </li>
  <li>
    <p>获取自己实现方法的 method 和原实现方法的 method.</p>
  </li>
  <li>
    <p>通过 <code>method_exchangeImplementations()</code> 函数交换两个方法.</p>
  </li>
</ol>

<p>注意: 这只是方法混写中的一种，交换两个实现方法，还有 <code>method_setImplementayion()</code>等方法.</p>

<h3 id="section-1">注意事项</h3>

<ol>
  <li>
    <p>方法混写最好在类的 category 中的 <code>+load</code> 方法中进行方法交换.</p>
  </li>
  <li>
    <p>方法混写的代码最好在 dispatch_once 中实现。</p>
  </li>
  <li>
    <p>要注意给自己实现的方法加上命名空间，以防止出现重复命名的问题，比如上述中的”<em>gh</em>“前缀.</p>
  </li>
  <li>
    <p>不要滥用这个方法,该方法被称之为 Objective-C 中的黑魔法，滥用会导致难以调试的bug.</p>
  </li>
  <li>
    <p>只要在 <code>+load</code> 中实现了 <code>method_exchangeImplementations()</code>, 那么该类的这个方法在整个应用的生命周期以内都被 Swizzling 了，要想调用原来正常的方法，就只能通过调用自己实现的方法名了。</p>
  </li>
</ol>

<h3 id="section-2">参考资料</h3>

<ol>
  <li>
    <p><a href="http://nshipster.com/method-swizzling/">Method Swizzling</a></p>
  </li>
  <li>
    <p><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411">Objective-C的hook方案（一）: Method Swizzling</a></p>
  </li>
  <li>
    <p><a href="http://www.cnblogs.com/kesalin/archive/2012/01/05/objc_method_swizzling.html">[Cocoa]深入浅出Cocoa之Method Swizzling</a></p>
  </li>
  <li>
    <p><a href="http://sjpsega.com/blog/2014/09/17/oc-method-swizzling/">Objective-C Method Swizzling</a></p>
  </li>
  <li>
    <p><a href="http://billwang1990.github.io/blog/2014/01/04/about-swizzling/">关于swizzling</a></p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C 中的对象关联(Associated Objects)]]></title>
    <link href="http://alex1212112.github.io/blog/2014/10/20/objective-czhong-de-dui-xiang-guan-lian-associated-objects/"/>
    <updated>2014-10-20T12:14:09+08:00</updated>
    <id>http://alex1212112.github.io/blog/2014/10/20/objective-czhong-de-dui-xiang-guan-lian-associated-objects</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201410201218.png" alt="" /></p>

<h3 id="section">目录</h3>

<ol>
  <li>什么是对象关联（Associated Objects）</li>
  <li>如何使用</li>
  <li>注意事项</li>
  <li>参考资料</li>
</ol>

<h3 id="associated-objects">什么是对象关联(Associated Objects)</h3>

<p>对象关联是Objective-C 2.0运行时的一个特性，起始于OS X Snow Leopard和iOS 4。我们有时候需要在对象中存放一些相关的信息，而又无法通过别的手段实现时，就可以把这些信息通过对象关联的方法与对象关联起来，在需要的时候通过对应的 key 就可以获取到对象的这些信息，比如说我们可以在 Category 中通过对象关联添加自定义的属性。对象关联通过  &lt;objc/runtime.h&gt; 中定义的三个方法实现的:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">void</span> <span class="nf">objc_setAssociatedObject</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">id</span> <span class="n">value</span><span class="p">,</span> <span class="n">objc_AssociationPolicy</span> <span class="n">policy</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="kt">id</span> <span class="nf">objc_getAssociatedObject</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="n">objc_removeAssociatedObjects</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">)</span><span class="err">；</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-1">如何使用对象关联</h3>

<p>我们可以使用关联对象在 Category 中添加自定义的属性，比如为一个 GHPerson 类添加一个体重的属性（weight）:</p>

<p>GHPerson+GHAssociatedObject.h</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &quot;GHPerson.h&quot;</span>
</span><span class="line">
</span><span class="line"><span class="k">@interface</span> <span class="nc">GHPerson</span> <span class="nl">(GHAssociatedObject)</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSNumber</span> <span class="o">*</span><span class="n">weight</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>

<p>GHPerson+GHAssociatedObject.m</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &quot;GHPerson+GHAssociatedObject.h&quot;</span>
</span><span class="line"><span class="cp">#import &lt;objc/runtime.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">char</span> <span class="n">weightKey</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">GHPerson</span> <span class="nl">(GHAssociatedObject)</span>
</span><span class="line"><span class="k">@dynamic</span> <span class="n">weight</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setWeight:</span><span class="p">(</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="p">)</span><span class="nv">weight</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">objc_setAssociatedObject</span> <span class="p">(</span><span class="nb">self</span><span class="p">,</span><span class="o">&amp;</span><span class="n">weightKey</span><span class="p">,</span><span class="n">weight</span><span class="p">,</span><span class="n">OBJC_ASSOCIATION_RETAIN</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="p">-</span> <span class="p">(</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="p">)</span><span class="nf">weight</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">   <span class="k">return</span> <span class="p">(</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">weightKey</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>
<p>其中 weightKey 是我们关联对象时用到的key，一般最好使用一个 char 类型的静态全局变量。从关联这个角度上看，我们用的属性不过是把对象关联到了一个实例变量上面。</p>

<p>我们看到 objc_setAssociatedObject 中的第 4 个参数，它表明了一个引用的关系，和 @property 中的属性等同：</p>

<blockquote>
  <p>OBJC_ASSOCIATION_ASSIGN   等同于 @property (assign) 或 @property (unsafe_unretained)</p>
</blockquote>

<blockquote>
  <p>OBJC_ASSOCIATION_RETAIN_NONATOMIC	等同于 @property (nonatomic, strong),其不可以被原子化</p>
</blockquote>

<blockquote>
  <p>OBJC_ASSOCIATION_COPY_NONATOMIC	    等同于 @property (nonatomic, copy),其不可以被原子化</p>
</blockquote>

<blockquote>
  <p>OBJC_ASSOCIATION_RETAIN  等同于  @property (atomic, strong),  可以被原子化</p>
</blockquote>

<blockquote>
  <p>OBJC_ASSOCIATION_COPY  等同于  @property (atomic, copy), 可以被原子化</p>
</blockquote>

<h3 id="section-2">注意事项</h3>

<ol>
  <li>不应该用 objc_removeAssociatedObjects() 来删除对象的属性，因为可能会导致其他客户对其添加的属性也被移除了。规范的方法是：调用 objc_setAssociatedObject 方法并传入一个 nil 值来清除一个关联。</li>
  <li>应该小心使用对象关联，不要滥用，因为可能会引起难以调试的bug。</li>
</ol>

<h3 id="section-3">参考资料</h3>

<ol>
  <li><a href="http://nshipster.cn/associated-objects/">Associated Objects</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于对象等同性判断]]></title>
    <link href="http://alex1212112.github.io/blog/2014/10/19/guan-yu-dui-xiang-deng-tong-xing-pan-duan/"/>
    <updated>2014-10-19T20:20:26+08:00</updated>
    <id>http://alex1212112.github.io/blog/2014/10/19/guan-yu-dui-xiang-deng-tong-xing-pan-duan</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201410192024.png" alt="" /></p>

<p>我们经常会遇到判断两个对象是否相等的的情况，如果食用 == 操作符来进行判断，比较出来多结果不一定是我们想要的，因为 == 操作符比较的事两个对象对指针，而不是对象的值。 NSObject 协议中有两个用语判断等同性的关键方法：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="bp">NSUInteger</span><span class="p">)</span><span class="nf">hash</span><span class="p">;</span>
</span><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>NSObject类对其的默认实现为当且仅当其指针完全相同的时候，两个对象才相等。我们要实现自己的对象等同性就要覆写这两个方法。 有一点要理解，如果 “isEqual:” 方法判断两个对象相等，那么其 hash 方法也必须返回同一个值，但是，如果两个对象的 hash 方法返回同一个值， “isEqual:” 方法却未必认为二者相等。</p>

<p>假如有一个Person类如下:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">Person</span> : <span class="bp">NSObject</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSNumber</span> <span class="o">*</span><span class="n">age</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>

<p>我们实现其等同性判断的步骤如下：</p>

<ol>
  <li>编写一个等同性判定方法，类似 NSString 类中的 <code>isEqualToString:</code> 方法，我们这里可以声明为 <code>isEqualToPerson:</code>.</li>
  <li>覆写 <code>isEqual:</code> 方法和 <code>hash</code> 方法.</li>
</ol>

<p>具体实现如下：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqualToPerson:</span><span class="p">(</span><span class="n">Person</span> <span class="o">*</span><span class="p">)</span><span class="nv">person</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span> <span class="o">==</span> <span class="n">person</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">([</span><span class="n">_name</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="n">person</span><span class="p">.</span><span class="n">name</span><span class="p">]</span> <span class="o">||</span> <span class="n">_name</span> <span class="o">==</span> <span class="n">person</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">([</span><span class="n">_age</span> <span class="nl">isEqualToNumber</span><span class="p">:</span><span class="n">person</span><span class="p">.</span><span class="n">age</span><span class="p">]</span> <span class="o">||</span> <span class="n">_age</span> <span class="o">==</span> <span class="n">person</span><span class="p">.</span><span class="n">age</span><span class="p">))</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="n">object</span> <span class="k">class</span><span class="p">])</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">isEqualToPerson</span><span class="p">:</span> <span class="p">(</span><span class="n">Person</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">isEqual</span><span class="p">:</span><span class="n">object</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="p">-</span> <span class="p">(</span><span class="bp">NSUInteger</span><span class="p">)</span><span class="nf">hash</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">_name</span> <span class="n">hash</span><span class="p">]</span> <span class="o">^</span> <span class="p">[</span><span class="n">_age</span> <span class="n">hash</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>至此，我们已经完成了符合自己需求的对象等同性判断。</p>

<h3 id="section">参考资料</h3>

<ol>
  <li><a href="http://www.objccn.io/issue-7-2/">值对象</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Foundation 框架中集合类的一些用法-NSArray]]></title>
    <link href="http://alex1212112.github.io/blog/2014/10/18/foundationkuang-jia-zhong-ji-he-lei-de-%5B%3F%5D-xie-yong-fa-nsarray/"/>
    <updated>2014-10-18T21:21:07+08:00</updated>
    <id>http://alex1212112.github.io/blog/2014/10/18/foundationkuang-jia-zhong-ji-he-lei-de-[?]-xie-yong-fa-nsarray</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201410191739.png" alt="" /></p>

<h3 id="section">目录</h3>

<ol>
  <li>遍历</li>
  <li>排序</li>
  <li>过滤</li>
  <li>其他</li>
  <li>参考资料</li>
</ol>

<h3 id="section-1">遍历</h3>

<h4 id="for">普通for循环</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="k">for</span> <span class="p">(</span><span class="bp">NSInteger</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="p">[</span><span class="n">array</span> <span class="n">count</span><span class="p">];</span> <span class="n">n</span> <span class="o">++</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h4 id="for-in-nsfastenumeration">for in 方式（NSFastEnumeration方式）</h4>

<p>该方式无法获取到数组的下标，在不需要下标且数组元素很多的时候，可以用这种方式</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="k">for</span> <span class="p">(</span><span class="kt">id</span> <span class="n">object</span> <span class="k">in</span> <span class="n">array</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
<p>####enumerateObjectsUsingBlock方式</p>

<p>数组遍历的 block 方式 ，其中的stop标志提供了一个优雅的停止遍历的方法，当 *stop = Yes 的时候，遍历就会停止</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="p">[</span><span class="n">array</span> <span class="nl">enumerateObjectsUsingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span> <span class="bp">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>

<h4 id="enumerateobjectswithoptions">enumerateObjectsWithOptions方式</h4>

<p>option 设置为 NSEnumerationConcurrent 为并发遍历方式,</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">array</span> <span class="nl">enumerateObjectsWithOptions</span><span class="p">:</span><span class="n">NSEnumerationConcurrent</span> <span class="nl">usingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>
<p>这里要注意使用并发方式进行遍历的话，最好不要在block里使用 NSMutableArray 之类的非线程安全的对象，当引起读写冲突的时候，会抛出 double free 的异常。</p>

<p>option 设置为 NSEnumerationReverse 为倒序遍历方式</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">array</span> <span class="nl">enumerateObjectsWithOptions</span><span class="p">:</span><span class="n">NSEnumerationReverse</span> <span class="nl">usingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-2">排序</h3>

<p>假如数组里要排序的对象如下；</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">User</span> : <span class="bp">NSObject</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSNumber</span> <span class="o">*</span><span class="n">age</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>

<h4 id="nsdescriptor">使用NSDescriptor进行排序</h4>

<p>按年龄和姓名进行排序,该方法可以对属性的多个key进行排序</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">sortDescriptors</span> <span class="o">=</span> <span class="l">@[</span><span class="p">[</span><span class="bp">NSSortDescriptor</span> <span class="nl">sortDescriptorWithKey</span><span class="p">:</span><span class="s">@&quot;age&quot;</span> <span class="nl">ascending</span><span class="p">:</span><span class="nb">YES</span><span class="p">],[</span><span class="bp">NSSortDescriptor</span> <span class="nl">sortDescriptorWithKey</span><span class="p">:</span><span class="s">@&quot;name&quot;</span> <span class="nl">ascending</span><span class="p">:</span><span class="nb">YES</span><span class="p">]</span><span class="l">]</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">sortedArray</span> <span class="o">=</span>  <span class="p">[</span><span class="n">array</span> <span class="nl">sortedArrayUsingDescriptors</span><span class="p">:</span><span class="n">sortDescriptors</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<h4 id="nscomparator">使用NSComparator进行排序</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">sortedArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">sortedArrayUsingComparator</span><span class="p">:</span><span class="o">^</span><span class="n">NSComparisonResult</span><span class="p">(</span><span class="n">User</span> <span class="o">*</span><span class="n">user1</span><span class="p">,</span> <span class="n">User</span> <span class="o">*</span><span class="n">user2</span><span class="p">){</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">user1</span><span class="p">.</span><span class="n">age</span> <span class="nl">compare</span><span class="p">:</span><span class="n">user2</span><span class="p">.</span><span class="n">age</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>

<h4 id="selctor">使用selctor</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">sortedArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">sortedArrayUsingSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">compare</span><span class="p">:)];</span>
</span></code></pre></td></tr></table></div></figure>

<p>其中compare为 User对象的方法</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="n">NSComparisonResult</span><span class="p">)</span><span class="nf">compare:</span><span class="p">(</span><span class="n">User</span> <span class="o">*</span><span class="p">)</span><span class="nv">otherUser</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">age</span> <span class="nl">compare</span><span class="p">:</span><span class="n">otherUser</span><span class="p">.</span><span class="n">age</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-3">过滤</h3>

<p>有时候需要按照一定规则从数组中过滤出符合要求的元素，这时候就要用到NSPredicate了,常用的格式化的用法如下：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSPredicate</span> <span class="o">*</span><span class="n">predicate</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSPredicate</span> <span class="nl">predicateWithFormat</span><span class="p">:</span><span class="s">@&quot;((age &gt;= %@) AND (age &lt; %@))&quot;</span><span class="p">,</span><span class="mi">@20</span><span class="p">,</span><span class="mi">@30</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">filteredArrayUsingPredicate</span><span class="p">:</span><span class="n">predicate</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>这个便返回了 user 数组中 age 在 20 到 30 之间的元素。</p>

<p>NSPredicate 也有个 block 用法</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSPredicate</span> <span class="o">*</span><span class="n">predicate</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSPredicate</span> <span class="nl">predicateWithBlock</span><span class="p">:</span><span class="o">^</span><span class="kt">BOOL</span><span class="p">(</span><span class="kt">id</span> <span class="n">evaluatedObject</span><span class="p">,</span> <span class="bp">NSDictionary</span> <span class="o">*</span><span class="n">bindings</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">        <span class="k">return</span>  <span class="p">((</span><span class="n">User</span> <span class="o">*</span><span class="p">)</span><span class="n">evaluatedObject</span><span class="p">).</span><span class="n">age</span> <span class="o">&gt;=</span> <span class="mi">20</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">User</span> <span class="o">*</span><span class="p">)</span><span class="n">evaluatedObject</span><span class="p">).</span><span class="n">age</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="p">}];</span>
</span><span class="line">
</span><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">filteredArrayUsingPredicate</span><span class="p">:</span><span class="n">predicate</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-4">其他</h3>

<h4 id="section-5">去重</h4>

<p>有一个优雅的KVC用法</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">valueForKeyPath</span><span class="p">:</span><span class="s">@&quot;@distinctUnionOfObjects.self&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>别忘了前面 distinctUnionOfObjects 前面的 @ 符号,假如只想返回一个由user数组中的姓名组成的不重复的新数组，可以</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">valueForKeyPath</span><span class="p">:</span><span class="s">@&quot;@distinctUnionOfObjects.name&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<p>还要注意假如数组里面存储的是我们自己的对象多话，这个对象还要实现等通性判断的方法：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span><span class="p">;</span>
</span><span class="line"><span class="p">-</span> <span class="p">(</span><span class="bp">NSUInteger</span><span class="p">)</span><span class="nf">hash</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>
<p>假如不实现等同性判断的话，系统默认的会把两个对象的指针相同才认为是同一个对象，有时候这显然不是我们想要的. 对象等同性具体实现可参考<a href="http://alex1212112.github.io/blog/2014/10/19/guan-yu-dui-xiang-deng-tong-xing-pan-duan/">对象等同性判断</a>。</p>

<h3 id="section-6">参考资料</h3>

<ol>
  <li>
    <p><a href="http://beyondvincent.com/blog/2014/01/26/how-to-sort-nsarray-with-custom-objects/">对 NSArray 中自定义的对象进行排序</a></p>
  </li>
  <li>
    <p><a href="http://objccn.io/issue-7-1/">基础集合类</a></p>
  </li>
  <li>
    <p><a href="http://blog.sunnyxx.com/2014/04/30/ios_iterator/">ios中集合遍历方法的比较和技巧</a></p>
  </li>
  <li>
    <p><a href="http://nshipster.cn/nspredicate/">NSPredicate</a></p>
  </li>
  <li>
    <p><a href="http://nshipster.cn/kvc-collection-operators/">KVC Collection Operators</a></p>
  </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVO 简介]]></title>
    <link href="http://alex1212112.github.io/blog/2014/09/02/kvojian-jie/"/>
    <updated>2014-09-02T16:24:18+08:00</updated>
    <id>http://alex1212112.github.io/blog/2014/09/02/kvojian-jie</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201409021638.png" alt="" /></p>

<h3 id="section">目录</h3>

<p>什么是KVO？</p>

<p>KVO使用流程</p>

<p>KVO实例</p>

<p>相关技巧</p>

<p>参考资料</p>

<h3 id="kvo">什么是KVO？</h3>

<p>KVO提供了一种观察者机制，当指定的对象的属性发生变化的时候，观察者就会收到通知，我们可以根据通知来进行UI更新等操作。它能降低代码之间的藕合度，显著减少开发者编写的代码量。KVO 是 Cocoa 的一项特性，我们可以在 Foundation 的框架里找到它。</p>

<h3 id="kvo-1">KVO使用流程</h3>

<ul>
  <li>添加观察者（注册KVO),一般在观察者对象初始化的时候，添加观察者</li>
</ul>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addObserver:</span><span class="p">(</span><span class="bp">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="nv">observer</span> <span class="nf">forKeyPath:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">keyPath</span> <span class="nf">options:</span><span class="p">(</span><span class="n">NSKeyValueObservingOptions</span><span class="p">)</span><span class="nv">options</span> <span class="nf">context:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<ul>
  <li>属性变化时的回调</li>
</ul>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">observeValueForKeyPath:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">keyPath</span> <span class="nf">ofObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span> <span class="nf">change:</span><span class="p">(</span><span class="bp">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">change</span> <span class="nf">context:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<ul>
  <li>移除观察者（注销KVO),一般在观察者对象释放的时候移除，比如在dealloc中移除</li>
</ul>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeObserver:</span><span class="p">(</span><span class="bp">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="nv">observer</span> <span class="nf">forKeyPath:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">keyPath</span> <span class="nf">context:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="kvo-2">KVO实例</h3>

<p>这里举一个例子，比如我有一个Person的对象如下：</p>

<p>Person.h</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">Person</span> : <span class="bp">NSObject</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSNumber</span> <span class="o">*</span><span class="n">age</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>
<p>我们的viewController中会引用到该person对象，并在viewController的 - (void)viewWillAppear:(BOOL)animated 方法中注册KVO：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="p">[[</span><span class="n">Person</span> <span class="n">sharePerson</span><span class="p">]</span> <span class="nl">addObserver</span><span class="p">:</span><span class="nb">self</span> <span class="nl">forKeyPath</span><span class="p">:</span><span class="s">@&quot;name&quot;</span> <span class="nl">options</span><span class="p">:</span><span class="n">NSKeyValueObservingOptionInitial</span> <span class="nl">context</span><span class="p">:(</span><span class="k">__bridge</span> <span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">];</span>
</span><span class="line"> <span class="p">[[</span><span class="n">Person</span> <span class="n">sharePerson</span><span class="p">]</span> <span class="nl">addObserver</span><span class="p">:</span><span class="nb">self</span> <span class="nl">forKeyPath</span><span class="p">:</span><span class="s">@&quot;age&quot;</span> <span class="nl">options</span><span class="p">:</span><span class="n">NSKeyValueObservingOptionInitial</span> <span class="nl">context</span><span class="p">:(</span><span class="k">__bridge</span> <span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>当person的属性name或age变化的时候，viewController就会调用</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addObserver:</span><span class="p">(</span><span class="bp">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="nv">anObserver</span>
</span><span class="line">         <span class="nf">forKeyPath:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">keyPath</span>
</span><span class="line">            <span class="nf">options:</span><span class="p">(</span><span class="n">NSKeyValueObservingOptions</span><span class="p">)</span><span class="nv">options</span>
</span><span class="line">            <span class="nf">context:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span>
</span></code></pre></td></tr></table></div></figure>

<p>我们实现该方法如下：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">observeValueForKeyPath:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">keyPath</span> <span class="nf">ofObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span> <span class="nf">change:</span><span class="p">(</span><span class="bp">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">change</span> <span class="nf">context:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">((</span><span class="k">__bridge</span> <span class="kt">id</span><span class="p">)</span><span class="n">context</span> <span class="o">==</span> <span class="nb">self</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">([</span><span class="n">keyPath</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="s">@&quot;name&quot;</span><span class="p">])</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="nb">self</span><span class="p">.</span><span class="n">nameLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">Person</span> <span class="n">sharePerson</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">if</span> <span class="p">([</span><span class="n">keyPath</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="s">@&quot;age&quot;</span><span class="p">])</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="nb">self</span><span class="p">.</span><span class="n">ageLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Person</span> <span class="n">sharePerson</span><span class="p">].</span><span class="n">age</span> <span class="n">stringValue</span><span class="p">];</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="nb">super</span> <span class="nl">observeValueForKeyPath</span><span class="p">:</span><span class="n">keyPath</span> <span class="nl">ofObject</span><span class="p">:</span><span class="n">object</span> <span class="nl">change</span><span class="p">:</span><span class="n">change</span> <span class="nl">context</span><span class="p">:</span><span class="n">context</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>这样当person属性变化的时候，viewController就会更新nameLabel 和 ageLabel.</p>

<p>不要忘了最后要移除KVO，因为我们是在 - (void)viewWillAppear:(BOOL)animated 中添加的KVO，所以我们要在 - (void)viewWillDisappear:(BOOL)animated 中移除KVO，假如添加了KVO 而在观察者释放的时候没有移除KVO，那么对象会因为向已经释放的观察者发送消息而crash.让然移除的时候也不要移除没有添加到观察者的 keyPath，同样会导致程序crash.</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="nb">self</span> <span class="nl">removeObserver</span><span class="p">:</span><span class="nb">self</span> <span class="nl">forKeyPath</span><span class="p">:</span><span class="s">@&quot;name&quot;</span> <span class="nl">context</span><span class="p">:(</span><span class="k">__bridge</span> <span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="nb">self</span> <span class="nl">removeObserver</span><span class="p">:</span><span class="nb">self</span> <span class="nl">forKeyPath</span><span class="p">:</span><span class="s">@&quot;age&quot;</span> <span class="nl">context</span><span class="p">:(</span><span class="k">__bridge</span> <span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<p>这样，一个实现KVO的简单例子就完成了.  <a href="https://github.com/alex1212112/KVODemo">Demo</a>.</p>

<h3 id="section-1">相关技巧与说明</h3>

<ol>
  <li>
    <p>有时候需要在第一次运行代码的时候更新一次 UI。我们可以设置KVO的选项   NSKeyValueObservingOptionInitial 的选项。这将会让 KVO 通知在调用 -addObserver:forKeyPath:… 的时候也被触发。</p>
  </li>
  <li>
    <p>KVO 能降低代码的藕合度，是因为Model对象在改变的时候，所有观察者能自动的去处理相关逻辑，这样我们就不用在模型对象里去编写专门的代码去通知观察者了，从而保持了模型类的简洁性。</p>
  </li>
  <li>
    <p>有时候你可能想在第一次更新UI的时候去检查Model的属性是否为空，如果为空，就通过一些方法（比如方法A）去获取这个属性的值，再重新触发KVO，来更新获取到的新值，不过这里要注意方法A里假如也全是在主线程运行的话，第二次KVO就不会触发，因为KVO是同步运行在主线程上的，这样做可能是为了防止出现死循环吧，这时候就要在方法A里通过后台线程去获取属性的值，然后在主线程里把值赋给Model的属性，这样就能触发KVO了。</p>
  </li>
</ol>

<h3 id="section-2">参考资料</h3>

<ol>
  <li>
    <p><a href="http://objccn.io/issue-7-3/">KVC 和 KVO</a>;</p>
  </li>
  <li>
    <p><a href="http://nshipster.com/key-value-observing/">Key-Value Observing</a>;</p>
  </li>
  <li>
    <p><a href="http://blog.csdn.net/kesalin/article/details/8194240">[深入浅出Cocoa]详解键值观察（KVO）及其实现机理</a>;</p>
  </li>
  <li>
    <p><a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107-SW1">Key-Value Coding Programming Guide</a>;</p>
  </li>
  <li>
    <p><a href="http://blog.riaproject.com/objective-c/2147/%E4%BA%86%E8%A7%A3-objective-c-%E4%B8%8A%E7%9A%84-kvokey-value-observing-%E6%A9%9F%E5%88%B6.html">了解 Objective-C 上的 KVO(Key-Value Observing) 機制</a>;</p>
  </li>
  <li><a href="http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/">Objective-C中的KVC和KVO</a></li>
  <li><a href="http://beyondvincent.com/blog/2013/05/05/18/">iOS设计模式(01):观察者</a>；</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 中的字节序]]></title>
    <link href="http://alex1212112.github.io/blog/2014/08/12/ioszhong-de-zi-jie-xu/"/>
    <updated>2014-08-12T12:07:08+08:00</updated>
    <id>http://alex1212112.github.io/blog/2014/08/12/ioszhong-de-zi-jie-xu</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/b8c60f715c7d7ad3736a3efde8f56eae65d9d45810251-ck6IkC_fw658.png" alt="" /></p>

<h4 id="section">起因</h4>

<p>最近在做 iOS 蓝牙开发的时候，将多字节数据从APP端发到蓝牙设备端的时候，发现字节顺序都是反的，比如发送一个 0x0500 的数据给蓝牙设备端，设备端收到以后就变成了0x0005,研究发现这就是字节序不对导致的问题。</p>

<h4 id="section-1">什么是字节序</h4>

<p>采用维基百科的解释如下：</p>

<blockquote>
  <p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。</p>
</blockquote>

<blockquote>
  <p>而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效字节在最高有效字节的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。</p>
</blockquote>

<blockquote>
  <p>例如假设上述变量x类型为int，位于地址0x100处，它的十六进制为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 01, 0x101: 23,..。而小端法将是：0x100: 67, 0x101: 45,..</p>
</blockquote>

<p><img src="http://alex1212112.github.io/images/280px-Big-Endian.svg.png" alt="" /></p>

<p><img src="http://alex1212112.github.io/images/280px-Little-Endian.svg.png" alt="" /></p>

<h4 id="section-2">相关体系</h4>

<ul>
  <li>
    <p>x86，MOS Technology 6502，Z80，VAX，PDP-11等处理器为Little endian。</p>
  </li>
  <li>
    <p>Motorola 6800，Motorola 68000，PowerPC 970，System/370，SPARC（除V9外）等处理器为Big endian</p>
  </li>
  <li>
    <p>ARM, PowerPC (除PowerPC 970外), DEC Alpha, SPARC V9, MIPS, PA-RISC and IA64的字节序是可配置的。</p>
  </li>
  <li>
    <p>网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。伯克利socket API定义了一组转换函数，用于16和32bit整数在网络序和本机字节序之间的转换。htonl，htons用于本机序转换到网络序；ntohl，ntohs用于网络序转换到本机序。</p>
  </li>
</ul>

<h4 id="ios">iOS中的字节序</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">if</span> <span class="p">(</span><span class="n">NSHostByteOrder</span><span class="p">()</span> <span class="o">==</span> <span class="n">NS_LittleEndian</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;LittleEndian&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">NSHostByteOrder</span><span class="p">()</span> <span class="o">==</span> <span class="n">NS_BigEndian</span><span class="p">){</span>
</span><span class="line">         <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;BigEndian&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span> <span class="p">{</span>
</span><span class="line">         <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Unknow&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>通过上述代码打印出来的log，可以知道iOS系统目前采用的是小端序。因此在进行socket网络传输之类的工作时，要记得先把字节序进行转换，然后再传输。iOS自身提供了相应的转换方法，如下：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">UInt16</span>  <span class="n">Byte</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
</span><span class="line"><span class="n">HTONS</span><span class="p">(</span><span class="n">Byte</span><span class="p">);</span><span class="c1">//转换</span>
</span><span class="line"><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Byte == %x&quot;</span><span class="p">,</span><span class="n">Byte</span><span class="p">);</span><span class="c1">//打印出来发现顺序变了</span>
</span></code></pre></td></tr></table></div></figure>
<p>上述代码中 HTONS(x) 是对2字节进行转换，如果要对4字节进行转换，就要用 HTONL(x)进行转换了，要对更高字节，比如8字节（64位）进行转换，就要自己写转换的方法了。</p>

<h4 id="section-3">参考资料</h4>

<ol>
  <li>
    <p><a href="http://ixhan.com/2009/10/little-about-byte-order/">关于字节序</a>;</p>
  </li>
  <li>
    <p><a href="http://geeklu.com/2012/01/macios-socket/">Mac&amp;iOS Socket</a>;</p>
  </li>
  <li>
    <p><a href="http://blog.csdn.net/ernest201210/article/details/8690686"> 网络字节序与主机字节序 高低位</a>;</p>
  </li>
  <li>
    <p><a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F">字节序</a>;</p>
  </li>
  <li>
    <p><a href="https://developer.apple.com/library/mac/documentation/corefoundation/Conceptual/CFMemoryMgmt/Concepts/ByteOrdering.html">Byte Ordering</a>;</p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 中的断点续传]]></title>
    <link href="http://alex1212112.github.io/blog/2014/07/16/ioszhong-de-duan-dian-xu-chuan/"/>
    <updated>2014-07-16T17:25:31+08:00</updated>
    <id>http://alex1212112.github.io/blog/2014/07/16/ioszhong-de-duan-dian-xu-chuan</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201407161730.png" alt="" /></p>

<h4 id="section">关键点</h4>

<p>实现断点续传的关键是自定义http request的头部的range域属性</p>

<p>Range头域可以请求实体的一个或者多个子范围。例如，</p>

<p>表示头500个字节：bytes=0-499</p>

<p>表示第二个500字节：bytes=500-999</p>

<p>表示最后500个字节：bytes=-500</p>

<p>表示500字节以后的范围：bytes=500-</p>

<p>第一个和最后一个字节：bytes=0-0,-1</p>

<p>同时指定几个范围：bytes=500-600,601-999</p>

<h4 id="section-1">基本思想</h4>

<p>1、获取已下载文件的大小，用来确定下载的文件从什么地方开始续传(即获取range属性的范围);</p>

<p>2、设置http request请求头文件，要包含range属性;</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSMutableURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableURLRequest</span> <span class="nl">requestWithURL</span><span class="p">:</span><span class="n">url</span> <span class="nl">cachePolicy</span><span class="p">:</span><span class="n">NSURLRequestUseProtocolCachePolicy</span> <span class="nl">timeoutInterval</span><span class="p">:</span><span class="mf">5.0f</span><span class="p">];</span>
</span><span class="line">   <span class="c1">// 设置请求头文件</span>
</span><span class="line"><span class="bp">NSString</span> <span class="o">*</span><span class="n">rangeValue</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;bytes=%llu-&quot;</span><span class="p">,</span> <span class="n">from</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">request</span> <span class="nl">addValue</span><span class="p">:</span><span class="n">rangeValue</span> <span class="nl">forHTTPHeaderField</span><span class="p">:</span><span class="s">@&quot;Range&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<p>3、 发起http下载请求;</p>

<h4 id="section-2">具体实现</h4>

<p>可以用iOS自带的NSURLConnection，也可以使用第三方如AFNetWorking实现。</p>

<p><a href="http://www.cnblogs.com/liufeng24/p/3555303.html">NSURLConnection实现方法</a>；</p>

<p><a href="http://blog.csdn.net/zhaoxy_thu/article/details/21383515">AFNetworking实现方法</a>;</p>

<p><a href="https://github.com/thibaultCha/TCBlobDownload">TCBlobDownload</a>;</p>

<h4 id="section-3">参考资料</h4>

<p>1.<a href="http://blog.csdn.net/sirchenhua/article/details/7286312">ios 实现断点续传 一 nsurlconnection</a>;</p>

<p>2.<a href="http://longminxiang.blog.163.com/blog/static/5933298520137933235997/">IOS Http断点续传浅析</a>;</p>

<p>3.<a href="http://www.cnblogs.com/liufeng24/p/3555303.html">iOS开发网络编程之断点续传-NSURLConnection</a>;</p>

<p>4.<a href="http://blog.csdn.net/zhaoxy_thu/article/details/21383515">AFNetworking实现程序重新启动时的断点续传</a>；</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CGGeometry]]></title>
    <link href="http://alex1212112.github.io/blog/2014/07/01/cggeometry/"/>
    <updated>2014-07-01T12:35:54+08:00</updated>
    <id>http://alex1212112.github.io/blog/2014/07/01/cggeometry</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/201407011244.png" alt="" /></p>

<p>CGGeometry 是一个 Quartz 2D 框架中非常有用且好用的处理几何问题的基本组件，这里列出一些它的方法并简单说明如何使用。</p>

<h3 id="section">变换</h3>

<h4 id="cgrectoffset">CGRectOffset</h4>

<p>CGRectOffset: 返回一个原点在源矩形基础上进行了偏移的矩形。</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">CGRect</span> <span class="n">CGRectOffset</span><span class="p">(</span>
</span><span class="line">  <span class="bp">CGRect</span> <span class="n">rect</span><span class="p">,</span> <span class="c1">//源矩形</span>
</span><span class="line">  <span class="n">CGFloat</span> <span class="n">dx</span><span class="p">,</span>  <span class="c1">//x方向偏移距离</span>
</span><span class="line">  <span class="n">CGFloat</span> <span class="n">dy</span>   <span class="c1">//y方向偏移距离</span>
</span><span class="line"><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>为什么要用 CGRectOffset ？<a href="http://nshipster.cn/cggeometry/">NSHipster</a>解释如下:</p>

<blockquote>
  <p>它不仅能让你在同时改变水平和垂直位置的时候减少一行代码，更重要的是，它所表示的平移比直接分开操作原点的值更具有几何意义。</p>
</blockquote>

<h4 id="cgrectinset">CGRectInset</h4>

<p>CGRectInset: 返回一个与源矩形共中心点的，或大些或小些的新矩形。</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">CGRect</span> <span class="n">CGRectInset</span><span class="p">(</span>
</span><span class="line">  <span class="bp">CGRect</span> <span class="n">rect</span><span class="p">,</span> <span class="c1">//源矩形</span>
</span><span class="line">  <span class="n">CGFloat</span> <span class="n">dx</span><span class="p">,</span>  <span class="c1">// x方向左边减去dx，右边也减去dx（共2dx）</span>
</span><span class="line">  <span class="n">CGFloat</span> <span class="n">dy</span>   <span class="c1">// y方向上边减去dy，右边也减去dy（共2dy）</span>
</span><span class="line"><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>如果用 CGRectInset 作为缩放矩形的快捷方法，一般通用的做法是嵌套调用CGRectOffset，把CGRectInset的返回值作为CGRectOffset的参数。</p>

<p>如：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">CGRect</span> <span class="n">frame</span> <span class="err">＝</span> <span class="n">CGRectOffset</span><span class="p">(</span><span class="n">CGRectInset</span><span class="p">(</span><span class="n">rect</span><span class="p">,</span> <span class="mf">10.0f</span><span class="p">,</span> <span class="mf">10.0f</span><span class="p">),</span> <span class="mf">10.0f</span><span class="p">,</span> <span class="mf">10.0f</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>上述代码把源矩形rect的大小缩小了10，然后又向右平移了10，向下平移了10，</p>

<h4 id="cgrectintegral">CGRectIntegral</h4>

<p>CGRectIntegral: 返回包围源矩形的最小整数矩形。</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">CGRect</span> <span class="n">CGRectIntegral</span> <span class="p">(</span>
</span><span class="line">  <span class="bp">CGRect</span> <span class="n">rect</span>
</span><span class="line"><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>CGRectIntegral 用来对矩形取整，可以保证矩形对齐到像素边界，在非retina屏幕上能防止像素模糊。</p>

<h3 id="section-1">取值辅助函数</h3>

<h4 id="cgrectgetminmidmaxxy">CGRectGet[Min|Mid|Max][X|Y]</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetMinX</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span> <span class="c1">//获取矩形x坐标的最小值</span>
</span><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetMinY</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span> <span class="c1">//获取矩形y坐标的最小值 </span>
</span><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetMidX</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span><span class="c1">//获取矩形x坐标的中间值 </span>
</span><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetMidY</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span> <span class="c1">//获取矩形y坐标的中间值 </span>
</span><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetMaxX</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span> <span class="c1">// 获取矩形x坐标的最大值 </span>
</span><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetMaxY</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span><span class="err">）</span> <span class="c1">// 获取矩形y坐标的最大值 </span>
</span></code></pre></td></tr></table></div></figure>

<p>引用<a href="http://nshipster.cn/cggeometry/">NSHipster</a>说明如下：</p>

<blockquote>
  <p>用这些函数代替诸如frame.origin.x + frame.size.width之类的代码将更加清晰、语义上更为生动的（特别是用取中间和取最大函数）</p>
</blockquote>

<h4 id="cgrectgetwidthheight">CGRectGet[Width|Height]</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetHeight</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span> <span class="c1">//获取矩形的高</span>
</span><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetWidth</span>  <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span>  <span class="c1">//获取矩形的宽</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-2">常量</h3>

<h4 id="cgrectzero">CGRectZero</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">const</span> <span class="bp">CGRect</span> <span class="n">CGRectZero</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>一个原点在(0, 0)，且长宽均为 0 的常数矩形。这个零矩形与 CGRectMake(0.0f, 0.0f, 0.0f, 0.0f) 是等价的。当我们初始化一个视图时，它们的边框通常设置为CGRectZero，把具体的布局放到 -layoutSubviews中。</p>

<h4 id="cgrectnull">CGRectNull</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">const</span> <span class="bp">CGRect</span> <span class="n">CGRectNull</span><span class="err">；</span>
</span></code></pre></td></tr></table></div></figure>

<p>空矩形。这个会在，比如说，求两个不相交的矩形的相交部分时返回。注意，空矩形不是零矩形。</p>

<h4 id="cgrectinfinite">CGRectInfinite</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">const</span> <span class="bp">CGRect</span> <span class="n">CGRectInfinite</span><span class="err">；</span>
</span></code></pre></td></tr></table></div></figure>

<p>无穷大矩形,它与所有的点或矩形相交，包含所有矩形，且它与任何矩形的并集等于它自身。可以用 CGRectIsInfinite 来检查一矩形是否为无限大。</p>

<h3 id="section-3">分割矩形</h3>

<h4 id="cgrectdivide">CGRectDivide</h4>

<p>CGRectDivide: 将源矩形分为两个子矩形。</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">void</span> <span class="n">CGRectDivide</span><span class="p">(</span>
</span><span class="line">  <span class="bp">CGRect</span> <span class="n">rect</span><span class="p">,</span>
</span><span class="line">  <span class="bp">CGRect</span> <span class="o">*</span><span class="n">slice</span><span class="p">,</span>
</span><span class="line">  <span class="bp">CGRect</span> <span class="o">*</span><span class="n">remainder</span><span class="p">,</span>
</span><span class="line">  <span class="n">CGFloat</span> <span class="n">amount</span><span class="p">,</span>
</span><span class="line">  <span class="bp">CGRectEdge</span> <span class="n">edge</span>
</span><span class="line"><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>CGRectDivide 用以下方式将矩形分割为两部分：</p>

<ul>
  <li>
    <p>传入一个矩形并选择一条边（edge）（上，下，左，右）；</p>
  </li>
  <li>
    <p>平行那个边在矩形里量出amount的长度；</p>
  </li>
  <li>
    <p>从edge 到量出的amount区域都保存到slice 参数中；</p>
  </li>
  <li>
    <p>剩余的部分保存到remainder 参数中。</p>
  </li>
</ul>

<p>其中 edge 参数是一个CGRectEdge 枚举类型：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">enum</span> <span class="bp">CGRectEdge</span> <span class="p">{</span>
</span><span class="line">   <span class="n">CGRectMinXEdge</span><span class="p">,</span> <span class="c1">//矩形的左边</span>
</span><span class="line">   <span class="n">CGRectMinYEdge</span><span class="p">,</span> <span class="c1">//矩形的上边</span>
</span><span class="line">   <span class="n">CGRectMaxXEdge</span><span class="p">,</span> <span class="c1">//矩形的右边</span>
</span><span class="line">   <span class="n">CGRectMaxYEdge</span>  <span class="c1">//矩形的下边</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-4">比较</h3>

<p>判断两个点是否相等</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGPointEqualToPoint</span> <span class="p">(</span><span class="bp">CGPoint</span> <span class="n">A</span><span class="p">,</span><span class="bp">CGPoint</span> <span class="n">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>CGSizeAB是否相等</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGSizeEqualToSize</span> <span class="p">(</span><span class="bp">CGSize</span> <span class="n">A</span><span class="err">，</span><span class="bp">CGSize</span> <span class="n">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>矩形AB的位置大小是否相等</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectEqualToRect</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="err">，</span><span class="bp">CGRect</span> <span class="n">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>
<p>矩形AB是否相交</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectIntersectsRect</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="err">，</span><span class="bp">CGRect</span> <span class="n">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-5">包含关系</h3>

<p>检测矩形A是否包含指定的点B</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectContainsPoint</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="p">,</span> <span class="bp">CGPoint</span> <span class="n">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>检测矩形A是否包含矩形B</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectContainsRect</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="err">，</span><span class="bp">CGRect</span> <span class="n">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-6">检测矩形是否存在或是无穷大</h3>

<p>矩形A是否长和宽都是0，或者是个NULL</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectIsEmpty</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>
<p>矩形A是否为NULL</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectIsNull</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>
<p>矩形A是否无穷大，没有边界</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectIsInfinite</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-7">参考资料</h3>

<p><a href="http://nshipster.cn/cggeometry/">NSHipster</a>;</p>

<p><a href="http://www.cnblogs.com/xuling/archive/2012/02/09/2343427.html">Objective-c 中CGGeometry几何类常用方法简单整理</a>;</p>

<p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CGGeometry/Reference/reference.html">CGGeometry Reference</a>;</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVC 简介]]></title>
    <link href="http://alex1212112.github.io/blog/2014/06/30/kvcjian-jie/"/>
    <updated>2014-06-30T18:50:23+08:00</updated>
    <id>http://alex1212112.github.io/blog/2014/06/30/kvcjian-jie</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/2d7462592d67a98dbffc700f70ae01d4423b1c1256049.png" alt="" /></p>

<h3 id="section">目录</h3>

<p>什么是KVC？</p>

<p>为什么要用KVC？</p>

<p>KVC用法介绍.</p>

<h3 id="kvc">什么是KVC？</h3>

<p>KVC是cocoa的一部分，可以使我们在访问对象属性的时候不需要再调用 setter 和 getter存取器，比如我们可以用 [object valueForKey:property]来访问object对象中的property属性，也能用 [object setValue:value forKey:property]来给object对象中的property属性赋值。为了达到这种目的，对象需要用特定的方式来命名方法，这种命名约定就成为KVC.</p>

<h3 id="kvc-1">为什么要用KVC</h3>

<p>使用KVC能让我们在运行时而非编译时决定访问哪个属性，从而得到更灵活和更易于重用的对象，同时也能帮助我们减少代码量,通过KVC,还能实现cocoa中更为强大的KVO功能。</p>

<h3 id="kvc-2">KVC用法介绍</h3>

<p>我们定义一个对象如下</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">People</span> : <span class="bp">NSObject</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">age</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="n">Car</span> <span class="o">*</span><span class="n">car</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>

<h4 id="section-1">访问对象属性</h4>

<p>我们在获取people对象的name属性的值的时候，就可以通过KVC来获取：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="p">[</span><span class="n">people</span> <span class="nl">valueForKey</span><span class="p">:</span><span class="s">@&quot;name&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<p>此代码基本等同于下面代码</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">people</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>
<p>####用KVC赋值</p>

<p>KVC可以用setValue:forKey:修改可写属性：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">people</span> <span class="nl">setValue</span><span class="p">:</span><span class="s">@&quot;Alex&quot;</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;name&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>此代码基本等同与下面代码</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">people</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">@&quot;Alex&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>
<p>####keyPath</p>

<p>KVC 方法有 key 和keyPath 两个版本，比如 valueForkey: 和 valueForKeyPath:版本，这两者的区别在于，后者可以包含嵌套关系，用点分开，valueForKeyPath方法可以遍历所有的关系，如下所示：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSString</span> <span class="o">*</span><span class="n">carName</span> <span class="o">=</span> <span class="p">[</span><span class="n">people</span> <span class="nl">valueForKayPath</span><span class="p">:</span><span class="s">@&quot;car.name&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>此方法用来获取people对象的车的名称，可以基本等价于下面代码:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSString</span> <span class="o">*</span><span class="n">carName</span> <span class="o">=</span> <span class="p">[[</span><span class="n">people</span> <span class="n">car</span><span class="p">]</span> <span class="n">name</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>而 key方法不会遍历关系，假如你使用</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSString</span> <span class="o">*</span><span class="n">carName</span> <span class="o">=</span> <span class="p">[</span><span class="n">people</span> <span class="nl">valueForKay</span><span class="p">:</span><span class="s">@&quot;car.name&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>程序会去获取 people对象 的 car.name 属性，很明显，people 没有这样的属性，所以系统会抛出异常。</p>

<h4 id="kvc-3">KVC和非对象</h4>

<p>KVC 的 valueForKey:方法总是返回一个id对象，但不是每一个方法都会返回对象，那么对于标量，该方法返回值会自动用NSValue 或 NSNumber 来进行封装。因此我们在通过 KVC 赋值的对象为标量的时候，也应该先用 NSValue 或 NSNumber 进行封装，然后再使用 setValue:forKey:方法。</p>

<h4 id="section-2">高阶消息传递</h4>

<p>valueForKey:有很多有用的特例，比如对于 NSArray 或 NSSet 等容器类，使用 valueForKey:方法，实际上该方法会被传递给容器中的每一个对象，而不是对容器本身进行操作，它会对容器中的每个对象来查找这个键值，然后将查询结果打包到另一个容器中并返回给你。这样，我们就很容易用一个容器对象创建另一个容器对象。</p>

<p>比如：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">People</span> <span class="o">*</span><span class="n">developer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">People</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">developer</span> <span class="nl">setValue</span><span class="p">:</span><span class="s">@&quot;Alex&quot;</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;name&quot;</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">People</span> <span class="o">*</span><span class="n">teacher</span> <span class="o">=</span> <span class="p">[[</span><span class="n">People</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">teacher</span> <span class="nl">setValue</span><span class="p">:</span><span class="s">@&quot;Lucy&quot;</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;name&quot;</span><span class="p">];</span>
</span><span class="line">	
</span><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="l">@[</span><span class="n">developer</span><span class="p">,</span><span class="n">teacher</span><span class="l">]</span><span class="p">;</span>
</span><span class="line">	
</span><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">nameArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">valueForKey</span><span class="p">:</span><span class="s">@&quot;name&quot;</span><span class="p">];</span>
</span><span class="line">	
</span></code></pre></td></tr></table></div></figure>
<p>name 被传递给array中的每一个元素，并返回一个新的数组，新的数组中的元素是一个姓名的字符串。
对于 keyPath 使用方法也类似：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">nameLengthArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">valueForKeyPath</span><span class="p">:</span><span class="s">@&quot;name.length&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>新的数组中的元素是用 NSNumber 封装的姓名字符串的长度。</p>

<h4 id="kvcmodel">通过KVC创建Model</h4>

<p>我们经常会遇到需要将一个字典转化成一个对象情况，这时用 KVC 能很好的解决问题， KVC 中有一个setValuesForKeysWithDictionary: 方法，此方法能很好的把字典转换成我们需要的对象。比如我们可以给刚才的 People 类增加一个初始化方法:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-(</span><span class="kt">id</span><span class="p">)</span> <span class="nf">initWithDictionary:</span><span class="p">(</span><span class="bp">NSMutableDictionary</span><span class="o">*</span><span class="p">)</span> <span class="nv">jsonObject</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>实现如下：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-(</span><span class="kt">id</span><span class="p">)</span> <span class="nf">initWithDictionary:</span><span class="p">(</span><span class="bp">NSMutableDictionary</span><span class="o">*</span><span class="p">)</span> <span class="nv">jsonObject</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">((</span><span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">]))</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="nb">self</span> <span class="nl">setValuesForKeysWithDictionary</span><span class="p">:</span><span class="n">jsonObject</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h4 id="section-3">一些特殊的用法</h4>

<p>KVC还提供一些特殊的方法，例如获取一组值的平均值或返回这组值的最小值和最大值。例如：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="l">@[</span><span class="n">developer</span><span class="p">,</span><span class="n">teacher</span><span class="l">]</span><span class="p">;</span>
</span><span class="line"><span class="bp">NSNumber</span> <span class="o">*</span><span class="n">totalLength</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">valueForKeyPath</span><span class="p">:</span><span class="s">@&quot;name.@sum.length&quot;</span><span class="p">];</span> 	
</span></code></pre></td></tr></table></div></figure>
<p>@sum是一个操作符，对指定的属性（name.length）求和。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITableView 相关]]></title>
    <link href="http://alex1212112.github.io/blog/2014/06/13/uitableview-xiang-guan/"/>
    <updated>2014-06-13T13:48:02+08:00</updated>
    <id>http://alex1212112.github.io/blog/2014/06/13/uitableview-xiang-guan</id>
    <content type="html"><![CDATA[<p><img src="http://alex1212112.github.io/images/4902731144446386506.jpg" alt="" />
####问题描述：</p>

<p>UITableView deleteRowsAtIndexPaths:withRowAnimation:在使用的时候，当你删除该行的时候，tableView并不会reload，所以该	行的下一行的indexPath并没有改变，当下一行为最后一行的时候，你的Model里的数据在删除的时候调用[arrayremoveObjectAtIndex:indexPath.row] 时候会报错：数组越界。</p>

<h4 id="section">解决办法:</h4>

<p>假如你直接使用[tableView reloadData]，那么就看不到  tableView的动画效果了，所以不能用[tableView reloadData];代替的方法是使用 reloadSections:withRowAnimation:方法。</p>

<hr />

<h4 id="section-1">问题描述：</h4>

<p>如何设置UITableViewCell accessoryType的颜色？</p>

<h4 id="section-2">解决办法:</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">cell</span><span class="p">.</span><span class="n">tintColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">greenColor</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<p>注意：类型为UITableViewCellAccessoryDisclosureIndicator 的不能通过这种方法更改，其颜色只能灰色。</p>

<hr />

<h4 id="section-3">问题描述：</h4>

<p>如何获取UITableViewCell 在TableView中的frame？</p>

<h4 id="section-4">解决办法:</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="bp">CGRect</span> <span class="n">cellFrame</span> <span class="o">=</span> <span class="p">[</span><span class="n">_tableView</span> <span class="nl">rectForRowAtIndexPath</span><span class="p">:[</span><span class="bp">NSIndexPath</span> <span class="nl">indexPathForRow</span><span class="p">:</span><span class="n">index</span> <span class="nl">inSection</span><span class="p">:</span><span class="mi">0</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>
<hr />

<h4 id="section-5">问题描述：</h4>

<p>在使用Grouped UITableView的时候，如何去掉上面默认的空白</p>

<h4 id="section-6">解决办法:</h4>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">_tableView</span><span class="p">.</span><span class="n">tableHeaderView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="n">_tableView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="mf">0.01f</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>

<hr />

<h4 id="section-7">问题描述</h4>

<p>iOS8 如何如何使 tableView cell 自适应高度 ？</p>

<h4 id="section-8">解决办法</h4>

<p>对自定义的Cell 进行约束布局（Autolayout）,</p>

<p>在<code>viewDidLoad</code>里添加</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line">   <span class="nb">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">rowHeight</span> <span class="o">=</span> <span class="n">UITableViewAutomaticDimension</span><span class="p">;</span>
</span><span class="line">   <span class="nb">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">estimatedRowHeight</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
