
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Summerrose’s Blog</title>
  <meta name="author" content="ghren">

  
  <meta name="description" content="起因 最近在做 iOS 蓝牙开发的时候，将多字节数据从APP端发到蓝牙设备端的时候，发现字节顺序都是反的，比如发送一个 0x0500 的数据给蓝牙设备端，设备端收到以后就变成了0x0005,研究发现这就是字节序不对导致的问题。 什么是字节序 采用维基百科的解释如下： 在几乎所有的机器上， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://alex1212112.github.io/posts/4/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Summerrose’s Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Summerrose’s Blog</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="alex1212112.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/12/ioszhong-de-zi-jie-xu/">iOS 中的字节序</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-12T12:07:08+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:07 pm</span></time>
        
           | <a href="/blog/2014/08/12/ioszhong-de-zi-jie-xu/#disqus_thread"
             data-disqus-identifier="http://alex1212112.github.io/blog/2014/08/12/ioszhong-de-zi-jie-xu/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/b8c60f715c7d7ad3736a3efde8f56eae65d9d45810251-ck6IkC_fw658.png" alt="" /></p>

<h4 id="section">起因</h4>

<p>最近在做 iOS 蓝牙开发的时候，将多字节数据从APP端发到蓝牙设备端的时候，发现字节顺序都是反的，比如发送一个 0x0500 的数据给蓝牙设备端，设备端收到以后就变成了0x0005,研究发现这就是字节序不对导致的问题。</p>

<h4 id="section-1">什么是字节序</h4>

<p>采用维基百科的解释如下：</p>

<blockquote>
  <p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。</p>
</blockquote>

<blockquote>
  <p>而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效字节在最高有效字节的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。</p>
</blockquote>

<blockquote>
  <p>例如假设上述变量x类型为int，位于地址0x100处，它的十六进制为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 01, 0x101: 23,..。而小端法将是：0x100: 67, 0x101: 45,..</p>
</blockquote>

<p><img src="/images/280px-Big-Endian.svg.png" alt="" /></p>

<p><img src="/images/280px-Little-Endian.svg.png" alt="" /></p>

<h4 id="section-2">相关体系</h4>

<ul>
  <li>
    <p>x86，MOS Technology 6502，Z80，VAX，PDP-11等处理器为Little endian。</p>
  </li>
  <li>
    <p>Motorola 6800，Motorola 68000，PowerPC 970，System/370，SPARC（除V9外）等处理器为Big endian</p>
  </li>
  <li>
    <p>ARM, PowerPC (除PowerPC 970外), DEC Alpha, SPARC V9, MIPS, PA-RISC and IA64的字节序是可配置的。</p>
  </li>
  <li>
    <p>网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。伯克利socket API定义了一组转换函数，用于16和32bit整数在网络序和本机字节序之间的转换。htonl，htons用于本机序转换到网络序；ntohl，ntohs用于网络序转换到本机序。</p>
  </li>
</ul>

<h4 id="ios">iOS中的字节序</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">if</span> <span class="p">(</span><span class="n">NSHostByteOrder</span><span class="p">()</span> <span class="o">==</span> <span class="n">NS_LittleEndian</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;LittleEndian&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">NSHostByteOrder</span><span class="p">()</span> <span class="o">==</span> <span class="n">NS_BigEndian</span><span class="p">){</span>
</span><span class="line">         <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;BigEndian&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span> <span class="p">{</span>
</span><span class="line">         <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Unknow&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>通过上述代码打印出来的log，可以知道iOS系统目前采用的是小端序。因此在进行socket网络传输之类的工作时，要记得先把字节序进行转换，然后再传输。iOS自身提供了相应的转换方法，如下：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">UInt16</span>  <span class="n">Byte</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
</span><span class="line"><span class="n">HTONS</span><span class="p">(</span><span class="n">Byte</span><span class="p">);</span><span class="c1">//转换</span>
</span><span class="line"><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Byte == %x&quot;</span><span class="p">,</span><span class="n">Byte</span><span class="p">);</span><span class="c1">//打印出来发现顺序变了</span>
</span></code></pre></td></tr></table></div></figure>
<p>上述代码中 HTONS(x) 是对2字节进行转换，如果要对4字节进行转换，就要用 HTONL(x)进行转换了，要对更高字节，比如8字节（64位）进行转换，就要自己写转换的方法了。</p>

<h4 id="section-3">参考资料</h4>

<ol>
  <li>
    <p><a href="http://ixhan.com/2009/10/little-about-byte-order/">关于字节序</a>;</p>
  </li>
  <li>
    <p><a href="http://geeklu.com/2012/01/macios-socket/">Mac&amp;iOS Socket</a>;</p>
  </li>
  <li>
    <p><a href="http://blog.csdn.net/ernest201210/article/details/8690686"> 网络字节序与主机字节序 高低位</a>;</p>
  </li>
  <li>
    <p><a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F">字节序</a>;</p>
  </li>
  <li>
    <p><a href="https://developer.apple.com/library/mac/documentation/corefoundation/Conceptual/CFMemoryMgmt/Concepts/ByteOrdering.html">Byte Ordering</a>;</p>
  </li>
</ol>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/16/ioszhong-de-duan-dian-xu-chuan/">iOS 中的断点续传</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-07-16T17:25:31+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>5:25 pm</span></time>
        
           | <a href="/blog/2014/07/16/ioszhong-de-duan-dian-xu-chuan/#disqus_thread"
             data-disqus-identifier="http://alex1212112.github.io/blog/2014/07/16/ioszhong-de-duan-dian-xu-chuan/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/201407161730.png" alt="" /></p>

<h4 id="section">关键点</h4>

<p>实现断点续传的关键是自定义http request的头部的range域属性</p>

<p>Range头域可以请求实体的一个或者多个子范围。例如，</p>

<p>表示头500个字节：bytes=0-499</p>

<p>表示第二个500字节：bytes=500-999</p>

<p>表示最后500个字节：bytes=-500</p>

<p>表示500字节以后的范围：bytes=500-</p>

<p>第一个和最后一个字节：bytes=0-0,-1</p>

<p>同时指定几个范围：bytes=500-600,601-999</p>

<h4 id="section-1">基本思想</h4>

<p>1、获取已下载文件的大小，用来确定下载的文件从什么地方开始续传(即获取range属性的范围);</p>

<p>2、设置http request请求头文件，要包含range属性;</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSMutableURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableURLRequest</span> <span class="nl">requestWithURL</span><span class="p">:</span><span class="n">url</span> <span class="nl">cachePolicy</span><span class="p">:</span><span class="n">NSURLRequestUseProtocolCachePolicy</span> <span class="nl">timeoutInterval</span><span class="p">:</span><span class="mf">5.0f</span><span class="p">];</span>
</span><span class="line">   <span class="c1">// 设置请求头文件</span>
</span><span class="line"><span class="bp">NSString</span> <span class="o">*</span><span class="n">rangeValue</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;bytes=%llu-&quot;</span><span class="p">,</span> <span class="n">from</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">request</span> <span class="nl">addValue</span><span class="p">:</span><span class="n">rangeValue</span> <span class="nl">forHTTPHeaderField</span><span class="p">:</span><span class="s">@&quot;Range&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<p>3、 发起http下载请求;</p>

<h4 id="section-2">具体实现</h4>

<p>可以用iOS自带的NSURLConnection，也可以使用第三方如AFNetWorking实现。</p>

<p><a href="http://www.cnblogs.com/liufeng24/p/3555303.html">NSURLConnection实现方法</a>；</p>

<p><a href="http://blog.csdn.net/zhaoxy_thu/article/details/21383515">AFNetworking实现方法</a>;</p>

<p><a href="https://github.com/thibaultCha/TCBlobDownload">TCBlobDownload</a>;</p>

<h4 id="section-3">参考资料</h4>

<p>1.<a href="http://blog.csdn.net/sirchenhua/article/details/7286312">ios 实现断点续传 一 nsurlconnection</a>;</p>

<p>2.<a href="http://longminxiang.blog.163.com/blog/static/5933298520137933235997/">IOS Http断点续传浅析</a>;</p>

<p>3.<a href="http://www.cnblogs.com/liufeng24/p/3555303.html">iOS开发网络编程之断点续传-NSURLConnection</a>;</p>

<p>4.<a href="http://blog.csdn.net/zhaoxy_thu/article/details/21383515">AFNetworking实现程序重新启动时的断点续传</a>；</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/01/cggeometry/">CGGeometry</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-07-01T12:35:54+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>12:35 pm</span></time>
        
           | <a href="/blog/2014/07/01/cggeometry/#disqus_thread"
             data-disqus-identifier="http://alex1212112.github.io/blog/2014/07/01/cggeometry/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/201407011244.png" alt="" /></p>

<p>CGGeometry 是一个 Quartz 2D 框架中非常有用且好用的处理几何问题的基本组件，这里列出一些它的方法并简单说明如何使用。</p>

<h3 id="section">变换</h3>

<h4 id="cgrectoffset">CGRectOffset</h4>

<p>CGRectOffset: 返回一个原点在源矩形基础上进行了偏移的矩形。</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">CGRect</span> <span class="n">CGRectOffset</span><span class="p">(</span>
</span><span class="line">  <span class="bp">CGRect</span> <span class="n">rect</span><span class="p">,</span> <span class="c1">//源矩形</span>
</span><span class="line">  <span class="n">CGFloat</span> <span class="n">dx</span><span class="p">,</span>  <span class="c1">//x方向偏移距离</span>
</span><span class="line">  <span class="n">CGFloat</span> <span class="n">dy</span>   <span class="c1">//y方向偏移距离</span>
</span><span class="line"><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>为什么要用 CGRectOffset ？<a href="http://nshipster.cn/cggeometry/">NSHipster</a>解释如下:</p>

<blockquote>
  <p>它不仅能让你在同时改变水平和垂直位置的时候减少一行代码，更重要的是，它所表示的平移比直接分开操作原点的值更具有几何意义。</p>
</blockquote>

<h4 id="cgrectinset">CGRectInset</h4>

<p>CGRectInset: 返回一个与源矩形共中心点的，或大些或小些的新矩形。</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">CGRect</span> <span class="n">CGRectInset</span><span class="p">(</span>
</span><span class="line">  <span class="bp">CGRect</span> <span class="n">rect</span><span class="p">,</span> <span class="c1">//源矩形</span>
</span><span class="line">  <span class="n">CGFloat</span> <span class="n">dx</span><span class="p">,</span>  <span class="c1">// x方向左边减去dx，右边也减去dx（共2dx）</span>
</span><span class="line">  <span class="n">CGFloat</span> <span class="n">dy</span>   <span class="c1">// y方向上边减去dy，右边也减去dy（共2dy）</span>
</span><span class="line"><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>如果用 CGRectInset 作为缩放矩形的快捷方法，一般通用的做法是嵌套调用CGRectOffset，把CGRectInset的返回值作为CGRectOffset的参数。</p>

<p>如：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">CGRect</span> <span class="n">frame</span> <span class="err">＝</span> <span class="n">CGRectOffset</span><span class="p">(</span><span class="n">CGRectInset</span><span class="p">(</span><span class="n">rect</span><span class="p">,</span> <span class="mf">10.0f</span><span class="p">,</span> <span class="mf">10.0f</span><span class="p">),</span> <span class="mf">10.0f</span><span class="p">,</span> <span class="mf">10.0f</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>上述代码把源矩形rect的大小缩小了10，然后又向右平移了10，向下平移了10，</p>

<h4 id="cgrectintegral">CGRectIntegral</h4>

<p>CGRectIntegral: 返回包围源矩形的最小整数矩形。</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">CGRect</span> <span class="n">CGRectIntegral</span> <span class="p">(</span>
</span><span class="line">  <span class="bp">CGRect</span> <span class="n">rect</span>
</span><span class="line"><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>CGRectIntegral 用来对矩形取整，可以保证矩形对齐到像素边界，在非retina屏幕上能防止像素模糊。</p>

<h3 id="section-1">取值辅助函数</h3>

<h4 id="cgrectgetminmidmaxxy">CGRectGet[Min|Mid|Max][X|Y]</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetMinX</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span> <span class="c1">//获取矩形x坐标的最小值</span>
</span><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetMinY</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span> <span class="c1">//获取矩形y坐标的最小值 </span>
</span><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetMidX</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span><span class="c1">//获取矩形x坐标的中间值 </span>
</span><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetMidY</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span> <span class="c1">//获取矩形y坐标的中间值 </span>
</span><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetMaxX</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span> <span class="c1">// 获取矩形x坐标的最大值 </span>
</span><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetMaxY</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span><span class="err">）</span> <span class="c1">// 获取矩形y坐标的最大值 </span>
</span></code></pre></td></tr></table></div></figure>

<p>引用<a href="http://nshipster.cn/cggeometry/">NSHipster</a>说明如下：</p>

<blockquote>
  <p>用这些函数代替诸如frame.origin.x + frame.size.width之类的代码将更加清晰、语义上更为生动的（特别是用取中间和取最大函数）</p>
</blockquote>

<h4 id="cgrectgetwidthheight">CGRectGet[Width|Height]</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetHeight</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span> <span class="c1">//获取矩形的高</span>
</span><span class="line"><span class="n">CGFloat</span>  <span class="n">CGRectGetWidth</span>  <span class="p">(</span><span class="bp">CGRect</span> <span class="n">rect</span><span class="p">)</span>  <span class="c1">//获取矩形的宽</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-2">常量</h3>

<h4 id="cgrectzero">CGRectZero</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">const</span> <span class="bp">CGRect</span> <span class="n">CGRectZero</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>一个原点在(0, 0)，且长宽均为 0 的常数矩形。这个零矩形与 CGRectMake(0.0f, 0.0f, 0.0f, 0.0f) 是等价的。当我们初始化一个视图时，它们的边框通常设置为CGRectZero，把具体的布局放到 -layoutSubviews中。</p>

<h4 id="cgrectnull">CGRectNull</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">const</span> <span class="bp">CGRect</span> <span class="n">CGRectNull</span><span class="err">；</span>
</span></code></pre></td></tr></table></div></figure>

<p>空矩形。这个会在，比如说，求两个不相交的矩形的相交部分时返回。注意，空矩形不是零矩形。</p>

<h4 id="cgrectinfinite">CGRectInfinite</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">const</span> <span class="bp">CGRect</span> <span class="n">CGRectInfinite</span><span class="err">；</span>
</span></code></pre></td></tr></table></div></figure>

<p>无穷大矩形,它与所有的点或矩形相交，包含所有矩形，且它与任何矩形的并集等于它自身。可以用 CGRectIsInfinite 来检查一矩形是否为无限大。</p>

<h3 id="section-3">分割矩形</h3>

<h4 id="cgrectdivide">CGRectDivide</h4>

<p>CGRectDivide: 将源矩形分为两个子矩形。</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">void</span> <span class="n">CGRectDivide</span><span class="p">(</span>
</span><span class="line">  <span class="bp">CGRect</span> <span class="n">rect</span><span class="p">,</span>
</span><span class="line">  <span class="bp">CGRect</span> <span class="o">*</span><span class="n">slice</span><span class="p">,</span>
</span><span class="line">  <span class="bp">CGRect</span> <span class="o">*</span><span class="n">remainder</span><span class="p">,</span>
</span><span class="line">  <span class="n">CGFloat</span> <span class="n">amount</span><span class="p">,</span>
</span><span class="line">  <span class="bp">CGRectEdge</span> <span class="n">edge</span>
</span><span class="line"><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>CGRectDivide 用以下方式将矩形分割为两部分：</p>

<ul>
  <li>
    <p>传入一个矩形并选择一条边（edge）（上，下，左，右）；</p>
  </li>
  <li>
    <p>平行那个边在矩形里量出amount的长度；</p>
  </li>
  <li>
    <p>从edge 到量出的amount区域都保存到slice 参数中；</p>
  </li>
  <li>
    <p>剩余的部分保存到remainder 参数中。</p>
  </li>
</ul>

<p>其中 edge 参数是一个CGRectEdge 枚举类型：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">enum</span> <span class="bp">CGRectEdge</span> <span class="p">{</span>
</span><span class="line">   <span class="n">CGRectMinXEdge</span><span class="p">,</span> <span class="c1">//矩形的左边</span>
</span><span class="line">   <span class="n">CGRectMinYEdge</span><span class="p">,</span> <span class="c1">//矩形的上边</span>
</span><span class="line">   <span class="n">CGRectMaxXEdge</span><span class="p">,</span> <span class="c1">//矩形的右边</span>
</span><span class="line">   <span class="n">CGRectMaxYEdge</span>  <span class="c1">//矩形的下边</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-4">比较</h3>

<p>判断两个点是否相等</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGPointEqualToPoint</span> <span class="p">(</span><span class="bp">CGPoint</span> <span class="n">A</span><span class="p">,</span><span class="bp">CGPoint</span> <span class="n">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>CGSizeAB是否相等</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGSizeEqualToSize</span> <span class="p">(</span><span class="bp">CGSize</span> <span class="n">A</span><span class="err">，</span><span class="bp">CGSize</span> <span class="n">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>矩形AB的位置大小是否相等</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectEqualToRect</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="err">，</span><span class="bp">CGRect</span> <span class="n">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>
<p>矩形AB是否相交</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectIntersectsRect</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="err">，</span><span class="bp">CGRect</span> <span class="n">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-5">包含关系</h3>

<p>检测矩形A是否包含指定的点B</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectContainsPoint</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="p">,</span> <span class="bp">CGPoint</span> <span class="n">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>检测矩形A是否包含矩形B</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectContainsRect</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="err">，</span><span class="bp">CGRect</span> <span class="n">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-6">检测矩形是否存在或是无穷大</h3>

<p>矩形A是否长和宽都是0，或者是个NULL</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectIsEmpty</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>
<p>矩形A是否为NULL</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectIsNull</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>
<p>矩形A是否无穷大，没有边界</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">bool</span>  <span class="n">CGRectIsInfinite</span> <span class="p">(</span><span class="bp">CGRect</span> <span class="n">A</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-7">参考资料</h3>

<p><a href="http://nshipster.cn/cggeometry/">NSHipster</a>;</p>

<p><a href="http://www.cnblogs.com/xuling/archive/2012/02/09/2343427.html">Objective-c 中CGGeometry几何类常用方法简单整理</a>;</p>

<p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CGGeometry/Reference/reference.html">CGGeometry Reference</a>;</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/30/kvcjian-jie/">KVC 简介</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-06-30T18:50:23+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>6:50 pm</span></time>
        
           | <a href="/blog/2014/06/30/kvcjian-jie/#disqus_thread"
             data-disqus-identifier="http://alex1212112.github.io/blog/2014/06/30/kvcjian-jie/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/2d7462592d67a98dbffc700f70ae01d4423b1c1256049.png" alt="" /></p>

<h3 id="section">目录</h3>

<p>什么是KVC？</p>

<p>为什么要用KVC？</p>

<p>KVC用法介绍.</p>

<h3 id="kvc">什么是KVC？</h3>

<p>KVC是cocoa的一部分，可以使我们在访问对象属性的时候不需要再调用 setter 和 getter存取器，比如我们可以用 [object valueForKey:property]来访问object对象中的property属性，也能用 [object setValue:value forKey:property]来给object对象中的property属性赋值。为了达到这种目的，对象需要用特定的方式来命名方法，这种命名约定就成为KVC.</p>

<h3 id="kvc-1">为什么要用KVC</h3>

<p>使用KVC能让我们在运行时而非编译时决定访问哪个属性，从而得到更灵活和更易于重用的对象，同时也能帮助我们减少代码量,通过KVC,还能实现cocoa中更为强大的KVO功能。</p>

<h3 id="kvc-2">KVC用法介绍</h3>

<p>我们定义一个对象如下</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">People</span> : <span class="bp">NSObject</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">age</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="n">Car</span> <span class="o">*</span><span class="n">car</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>

<h4 id="section-1">访问对象属性</h4>

<p>我们在获取people对象的name属性的值的时候，就可以通过KVC来获取：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="p">[</span><span class="n">people</span> <span class="nl">valueForKey</span><span class="p">:</span><span class="s">@&quot;name&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<p>此代码基本等同于下面代码</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">people</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>
<p>####用KVC赋值</p>

<p>KVC可以用setValue:forKey:修改可写属性：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">people</span> <span class="nl">setValue</span><span class="p">:</span><span class="s">@&quot;Alex&quot;</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;name&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>此代码基本等同与下面代码</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">people</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">@&quot;Alex&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>
<p>####keyPath</p>

<p>KVC 方法有 key 和keyPath 两个版本，比如 valueForkey: 和 valueForKeyPath:版本，这两者的区别在于，后者可以包含嵌套关系，用点分开，valueForKeyPath方法可以遍历所有的关系，如下所示：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSString</span> <span class="o">*</span><span class="n">carName</span> <span class="o">=</span> <span class="p">[</span><span class="n">people</span> <span class="nl">valueForKayPath</span><span class="p">:</span><span class="s">@&quot;car.name&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>此方法用来获取people对象的车的名称，可以基本等价于下面代码:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSString</span> <span class="o">*</span><span class="n">carName</span> <span class="o">=</span> <span class="p">[[</span><span class="n">people</span> <span class="n">car</span><span class="p">]</span> <span class="n">name</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>而 key方法不会遍历关系，假如你使用</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSString</span> <span class="o">*</span><span class="n">carName</span> <span class="o">=</span> <span class="p">[</span><span class="n">people</span> <span class="nl">valueForKay</span><span class="p">:</span><span class="s">@&quot;car.name&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>程序会去获取 people对象 的 car.name 属性，很明显，people 没有这样的属性，所以系统会抛出异常。</p>

<h4 id="kvc-3">KVC和非对象</h4>

<p>KVC 的 valueForKey:方法总是返回一个id对象，但不是每一个方法都会返回对象，那么对于标量，该方法返回值会自动用NSValue 或 NSNumber 来进行封装。因此我们在通过 KVC 赋值的对象为标量的时候，也应该先用 NSValue 或 NSNumber 进行封装，然后再使用 setValue:forKey:方法。</p>

<h4 id="section-2">高阶消息传递</h4>

<p>valueForKey:有很多有用的特例，比如对于 NSArray 或 NSSet 等容器类，使用 valueForKey:方法，实际上该方法会被传递给容器中的每一个对象，而不是对容器本身进行操作，它会对容器中的每个对象来查找这个键值，然后将查询结果打包到另一个容器中并返回给你。这样，我们就很容易用一个容器对象创建另一个容器对象。</p>

<p>比如：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">People</span> <span class="o">*</span><span class="n">developer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">People</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">developer</span> <span class="nl">setValue</span><span class="p">:</span><span class="s">@&quot;Alex&quot;</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;name&quot;</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">People</span> <span class="o">*</span><span class="n">teacher</span> <span class="o">=</span> <span class="p">[[</span><span class="n">People</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">teacher</span> <span class="nl">setValue</span><span class="p">:</span><span class="s">@&quot;Lucy&quot;</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;name&quot;</span><span class="p">];</span>
</span><span class="line">	
</span><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="l">@[</span><span class="n">developer</span><span class="p">,</span><span class="n">teacher</span><span class="l">]</span><span class="p">;</span>
</span><span class="line">	
</span><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">nameArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">valueForKey</span><span class="p">:</span><span class="s">@&quot;name&quot;</span><span class="p">];</span>
</span><span class="line">	
</span></code></pre></td></tr></table></div></figure>
<p>name 被传递给array中的每一个元素，并返回一个新的数组，新的数组中的元素是一个姓名的字符串。
对于 keyPath 使用方法也类似：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">nameLengthArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">valueForKeyPath</span><span class="p">:</span><span class="s">@&quot;name.length&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>
<p>新的数组中的元素是用 NSNumber 封装的姓名字符串的长度。</p>

<h4 id="kvcmodel">通过KVC创建Model</h4>

<p>我们经常会遇到需要将一个字典转化成一个对象情况，这时用 KVC 能很好的解决问题， KVC 中有一个setValuesForKeysWithDictionary: 方法，此方法能很好的把字典转换成我们需要的对象。比如我们可以给刚才的 People 类增加一个初始化方法:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-(</span><span class="kt">id</span><span class="p">)</span> <span class="nf">initWithDictionary:</span><span class="p">(</span><span class="bp">NSMutableDictionary</span><span class="o">*</span><span class="p">)</span> <span class="nv">jsonObject</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>实现如下：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">-(</span><span class="kt">id</span><span class="p">)</span> <span class="nf">initWithDictionary:</span><span class="p">(</span><span class="bp">NSMutableDictionary</span><span class="o">*</span><span class="p">)</span> <span class="nv">jsonObject</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">((</span><span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">]))</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="nb">self</span> <span class="nl">setValuesForKeysWithDictionary</span><span class="p">:</span><span class="n">jsonObject</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h4 id="section-3">一些特殊的用法</h4>

<p>KVC还提供一些特殊的方法，例如获取一组值的平均值或返回这组值的最小值和最大值。例如：</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="l">@[</span><span class="n">developer</span><span class="p">,</span><span class="n">teacher</span><span class="l">]</span><span class="p">;</span>
</span><span class="line"><span class="bp">NSNumber</span> <span class="o">*</span><span class="n">totalLength</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">valueForKeyPath</span><span class="p">:</span><span class="s">@&quot;name.@sum.length&quot;</span><span class="p">];</span> 	
</span></code></pre></td></tr></table></div></figure>
<p>@sum是一个操作符，对指定的属性（name.length）求和。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/13/uitableview-xiang-guan/">UITableView 相关</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-06-13T13:48:02+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>1:48 pm</span></time>
        
           | <a href="/blog/2014/06/13/uitableview-xiang-guan/#disqus_thread"
             data-disqus-identifier="http://alex1212112.github.io/blog/2014/06/13/uitableview-xiang-guan/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/4902731144446386506.jpg" alt="" />
####问题描述：</p>

<p>UITableView deleteRowsAtIndexPaths:withRowAnimation:在使用的时候，当你删除该行的时候，tableView并不会reload，所以该	行的下一行的indexPath并没有改变，当下一行为最后一行的时候，你的Model里的数据在删除的时候调用[arrayremoveObjectAtIndex:indexPath.row] 时候会报错：数组越界。</p>

<h4 id="section">解决办法:</h4>

<p>假如你直接使用[tableView reloadData]，那么就看不到  tableView的动画效果了，所以不能用[tableView reloadData];代替的方法是使用 reloadSections:withRowAnimation:方法。</p>

<hr />

<h4 id="section-1">问题描述：</h4>

<p>如何设置UITableViewCell accessoryType的颜色？</p>

<h4 id="section-2">解决办法:</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">cell</span><span class="p">.</span><span class="n">tintColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">greenColor</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

<p>注意：类型为UITableViewCellAccessoryDisclosureIndicator 的不能通过这种方法更改，其颜色只能灰色。</p>

<hr />

<h4 id="section-3">问题描述：</h4>

<p>如何获取UITableViewCell 在TableView中的frame？</p>

<h4 id="section-4">解决办法:</h4>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="bp">CGRect</span> <span class="n">cellFrame</span> <span class="o">=</span> <span class="p">[</span><span class="n">_tableView</span> <span class="nl">rectForRowAtIndexPath</span><span class="p">:[</span><span class="bp">NSIndexPath</span> <span class="nl">indexPathForRow</span><span class="p">:</span><span class="n">index</span> <span class="nl">inSection</span><span class="p">:</span><span class="mi">0</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>
<hr />

<h4 id="section-5">问题描述：</h4>

<p>在使用Grouped UITableView的时候，如何去掉上面默认的空白</p>

<h4 id="section-6">解决办法:</h4>
<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">_tableView</span><span class="p">.</span><span class="n">tableHeaderView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="n">_tableView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="mf">0.01f</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>

<hr />

<h4 id="section-7">问题描述</h4>

<p>iOS8 如何如何使 tableView cell 自适应高度 ？</p>

<h4 id="section-8">解决办法</h4>

<p>对自定义的Cell 进行约束布局（Autolayout）,</p>

<p>在<code>viewDidLoad</code>里添加</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line">   <span class="nb">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">rowHeight</span> <span class="o">=</span> <span class="n">UITableViewAutomaticDimension</span><span class="p">;</span>
</span><span class="line">   <span class="nb">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">estimatedRowHeight</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/5">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/3">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - ghren -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'alex1212112';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
